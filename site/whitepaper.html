<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAZE Whitepaper</title>
    <meta name="description" content="Technical whitepaper for MAZE: architecture, design, and implementation details.">

    <!-- Favicons -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://rand.github.io/maze/">
    <meta property="og:title" content="MAZE: Constrained Code Generation & Configuration Engine">
    <meta property="og:description" content="A principled authorization and configuration system combining Datalog and Cedar policies. Sub-millisecond decisions at 5M+ ops/sec.">
    <meta property="og:image" content="https://rand.github.io/maze/og-image.png">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://rand.github.io/maze/">
    <meta name="twitter:title" content="MAZE: Constrained Code Generation & Configuration Engine">
    <meta name="twitter:description" content="A principled authorization and configuration system combining Datalog and Cedar policies. Sub-millisecond decisions at 5M+ ops/sec.">
    <meta name="twitter:image" content="https://rand.github.io/maze/og-image.png">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/geist@1.0.0/dist/geist.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="nav-brand">
                <span class="logo-glyph"></span>
                <strong>MAZE</strong> v0.1.0
            </a>
            <div class="nav-links">
                
                    
                        <a href="whitepaper.html">Whitepaper</a>
                    
                
                    
                        <a href="https://github.com/rand/maze" target="_blank">GitHub</a>
                    
                
                <button class="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-toggle-icon"></span>
                </button>
            </div>
        </div>
    </nav>

    <aside class="sidebar">
        <div class="sidebar-content">
            <div class="sidebar-tagline">// Constrained Code Generation</div>
        </div>
    </aside>

    <main class="container">
        
<h1 id="maze-whitepaper">MAZE Whitepaper<a class="headerlink" href="#maze-whitepaper" title="Permanent link">&para;</a></h1>
<p><strong>Adaptive Constrained Code Generation</strong></p>
<p><strong>Version</strong>: v0.1.0-whitepaper
<strong>Date</strong>: November 2025
<strong>Repository</strong>: <a href="https://github.com/rand/maze">github.com/rand/maze</a></p>
<h2 id="abstract">Abstract<a class="headerlink" href="#abstract" title="Permanent link">&para;</a></h2>
<p>Large Language Models (LLMs) have demonstrated remarkable capabilities in code generation, yet they suffer from high error rates when generating complex, type-correct code. Unconstrained generation often produces syntactically valid but semantically incorrect or type-unsafe code, requiring expensive post-hoc validation and multiple repair iterations.</p>
<p>MAZE introduces a paradigm shift: <strong>compile constraints before decoding, rather than hoping for correctness after generation</strong>. Through a novel 4-tier constraint hierarchy‚Äîsyntactic (CFG grammars), type (inhabitation search), semantic (test-driven), and contextual (learned patterns)‚ÄîMAZE guides LLM generation toward valid, type-correct, and project-conformant code from the start.</p>
<p>Built on research from PLDI 2025 (Type-Constrained Code Generation) and OOPSLA 2024 (Typed Holes), MAZE integrates with multiple LLM providers (OpenAI, vLLM, SGLang, llama.cpp) through llguidance for constraint enforcement, mnemosyne for persistent learning, and RUNE for sandboxed validation.</p>
<p><strong>Current status</strong>: Core constraint system complete (Phases 1-3), validation pipeline in active development (Phase 4: 6/10 tasks complete), with adaptive learning and production hardening planned (Phases 5-6).</p>
<p><strong>Significance</strong>: MAZE demonstrates that formal constraint enforcement can be integrated with modern LLMs without sacrificing generation speed, providing a foundation for the next generation of AI-assisted development tools.</p>
<hr />
<h2 id="table-of-contents">Table of Contents<a class="headerlink" href="#table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-introduction">Introduction</a></li>
<li><a href="#2-problem-statement">Problem Statement</a></li>
<li><a href="#3-architecture-overview">Architecture Overview</a></li>
<li><a href="#4-4-tier-constraint-system">4-Tier Constraint System</a></li>
<li><a href="#5-type-directed-synthesis">Type-Directed Synthesis</a></li>
<li><a href="#6-integration-ecosystem">Integration Ecosystem</a></li>
<li><a href="#7-implementation-status-and-roadmap">Implementation Status and Roadmap</a></li>
<li><a href="#8-research-foundation">Research Foundation</a></li>
<li><a href="#9-architecture-validation">Architecture Validation</a></li>
<li><a href="#10-getting-started">Getting Started</a></li>
<li><a href="#11-conclusion">Conclusion</a></li>
<li><a href="#12-resources">Resources</a></li>
</ol>
<hr />
<h2 id="1-introduction">1. Introduction<a class="headerlink" href="#1-introduction" title="Permanent link">&para;</a></h2>
<h3 id="the-code-generation-challenge">The Code Generation Challenge<a class="headerlink" href="#the-code-generation-challenge" title="Permanent link">&para;</a></h3>
<p>Large Language Models have revolutionized software development assistance, enabling developers to generate substantial code from natural language descriptions. However, this capability comes with a fundamental limitation: without explicit constraints, LLMs generate code based solely on statistical patterns learned from training data. This approach produces code that is often:</p>
<ul>
<li><strong>Syntactically plausible</strong> but incorrect</li>
<li><strong>Type-unsafe</strong>, causing compilation failures</li>
<li><strong>Semantically wrong</strong>, failing to implement the specified behavior</li>
<li><strong>Inconsistent</strong> with project conventions and patterns</li>
</ul>
<h3 id="mazes-paradigm-shift">MAZE's Paradigm Shift<a class="headerlink" href="#mazes-paradigm-shift" title="Permanent link">&para;</a></h3>
<p>MAZE reverses this paradigm. Instead of hoping the LLM generates correct code, MAZE <strong>compiles constraints before token generation</strong>, guiding the model toward valid outputs from the start.</p>
<p><strong>Traditional Approach</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Generate</span><span class="w"> </span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Validate</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Find</span><span class="w"> </span><span class="n">errors</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Fix</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Repeat</span>
</code></pre></div>

<p><strong>MAZE Approach</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Build</span><span class="w"> </span><span class="n">constraints</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Generate</span><span class="w"> </span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Minimal</span><span class="w"> </span><span class="n">validation</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Done</span>
</code></pre></div>

<h3 id="architecture-foundation">Architecture Foundation<a class="headerlink" href="#architecture-foundation" title="Permanent link">&para;</a></h3>
<p>MAZE is built on four key innovations:</p>
<ol>
<li><strong>4-Tier Constraint Hierarchy</strong>: Progressive constraint tightening from syntax through types, semantics, and context</li>
<li><strong>Type-Directed Synthesis</strong>: Bidirectional type inference and inhabitation search for type-correct code paths</li>
<li><strong>Multi-System Integration</strong>: Seamless integration with llguidance, mnemosyne, RUNE, and pedantic_raven</li>
<li><strong>Provider Agnosticism</strong>: Support for OpenAI, vLLM, SGLang, and llama.cpp through unified adapters</li>
</ol>
<h2 id="2-problem-statement">2. Problem Statement<a class="headerlink" href="#2-problem-statement" title="Permanent link">&para;</a></h2>
<h3 id="unconstrained-llm-generation-failures">Unconstrained LLM Generation Failures<a class="headerlink" href="#unconstrained-llm-generation-failures" title="Permanent link">&para;</a></h3>
<p>Consider a request to generate a TypeScript function:</p>
<div class="highlight"><pre><span></span><code>&quot;Create an async function that fetches a user by ID and returns their email&quot;
</code></pre></div>

<p>An unconstrained LLM might generate:</p>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">getUserEmail</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetchUser</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">email</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This code has multiple issues:</p>
<ol>
<li><strong>Missing type annotations</strong>: Parameters and return type unspecified</li>
<li><strong>Type safety violation</strong>: <code>user</code> might be <code>null</code> or <code>undefined</code></li>
<li><strong>Incomplete error handling</strong>: Network failures unhandled</li>
<li><strong>Contextual mismatch</strong>: May not match project's error handling patterns</li>
</ol>
<h3 id="the-cost-of-post-hoc-validation">The Cost of Post-Hoc Validation<a class="headerlink" href="#the-cost-of-post-hoc-validation" title="Permanent link">&para;</a></h3>
<p>Post-generation validation creates a costly feedback loop:</p>
<ul>
<li><strong>Iteration 1</strong>: Generate code ‚Üí Compile ‚Üí Find type errors ‚Üí Prompt for fixes</li>
<li><strong>Iteration 2</strong>: Generate fixes ‚Üí Compile ‚Üí Find new errors ‚Üí Prompt again</li>
<li><strong>Iteration 3</strong>: Generate fixes ‚Üí Compile ‚Üí Test ‚Üí Find semantic errors ‚Üí Prompt again</li>
</ul>
<p>In practice, research shows unconstrained generation often requires 3-5 iterations before producing working code. Each iteration consumes LLM API calls, increases latency, risks context window overflow, and frustrates developers.</p>
<h3 id="type-errors-in-generated-code">Type Errors in Generated Code<a class="headerlink" href="#type-errors-in-generated-code" title="Permanent link">&para;</a></h3>
<p>Type errors are particularly problematic because they cascade. A single type mismatch can cause compilation failures blocking all downstream work, silent bugs when type coercion hides errors, integration failures when code doesn't match API contracts, and maintenance burden as type-unsafe code spreads through the codebase.</p>
<p>Research by M√ºndler et al. (PLDI 2025) found that unconstrained LLMs produce type errors in over 50% of generated functions for typed languages like TypeScript and Rust.</p>
<h2 id="3-architecture-overview">3. Architecture Overview<a class="headerlink" href="#3-architecture-overview" title="Permanent link">&para;</a></h2>
<p>MAZE's architecture consists of five integrated stages that transform a code generation request into validated, type-correct code:</p>
<h3 id="stage-1-context-indexer">Stage 1: Context Indexer<a class="headerlink" href="#stage-1-context-indexer" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Extract structured information from source code to inform constraint synthesis</p>
<p><strong>Current Implementation</strong>:</p>
<ul>
<li><strong>TypeScript Indexer</strong> ‚úÖ Complete</li>
<li>Extracts functions, classes, interfaces, type aliases</li>
<li>Parses type annotations and generic parameters</li>
<li>Detects project style (indentation, quotes, semicolons)</li>
<li>Identifies test patterns (Jest, Mocha, Vitest)</li>
</ul>
<h3 id="stage-2-constraint-synthesis">Stage 2: Constraint Synthesis<a class="headerlink" href="#stage-2-constraint-synthesis" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Build hierarchical constraints from indexed context and generation request</p>
<p><strong>Components</strong>:</p>
<ol>
<li><strong>GrammarBuilder</strong> ‚úÖ: Generates CFG grammars in Lark format</li>
<li><strong>TypeToGrammarConverter</strong> ‚úÖ: Converts type constraints into grammar constraints</li>
<li><strong>SchemaBuilder</strong> ‚úÖ: Generates JSON Schema for structured output (OpenAI compatibility)</li>
</ol>
<h3 id="stage-3-decode-orchestrator">Stage 3: Decode Orchestrator<a class="headerlink" href="#stage-3-decode-orchestrator" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Generate code under constraints using provider-specific adapters</p>
<p><strong>Integration</strong>: llguidance for fast constraint enforcement</p>
<p><strong>Provider Adapters</strong> ‚úÖ:</p>
<ul>
<li><strong>OpenAI</strong>: JSON Schema mode via structured outputs</li>
<li><strong>vLLM</strong>: Full CFG grammar support</li>
<li><strong>SGLang</strong>: Native llguidance integration</li>
<li><strong>llama.cpp</strong>: Grammar-based generation</li>
</ul>
<h3 id="stage-4-post-validation">Stage 4: Post-Validation<a class="headerlink" href="#stage-4-post-validation" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Validate generated code across multiple dimensions in parallel</p>
<p><strong>Validators</strong> (parallel execution):</p>
<ol>
<li><strong>SyntaxValidator</strong> ‚úÖ Complete: Language-specific syntax checking</li>
<li><strong>TypeValidator</strong> ‚úÖ Complete: Type checking via language-specific tools</li>
<li><strong>TestValidator</strong> ‚úÖ Complete: Executes tests in RUNE sandbox</li>
<li><strong>LintValidator</strong> ‚úÖ Complete: Style checking (ESLint, Ruff, Clippy)</li>
<li><strong>ValidationPipeline</strong> ‚úÖ Complete: Orchestrates parallel validation</li>
</ol>
<h3 id="stage-5-repair-loop">Stage 5: Repair Loop<a class="headerlink" href="#stage-5-repair-loop" title="Permanent link">&para;</a></h3>
<p><strong>Status</strong>: üìã Planned (Phase 4)</p>
<p><strong>Planned Components</strong>:</p>
<ul>
<li>RepairOrchestrator: Manages repair iterations</li>
<li>DiagnosticAnalyzer: Interprets validation failures</li>
<li>ConstraintRefinement: Tightens constraints based on diagnostics</li>
</ul>
<h3 id="integration-flow">Integration Flow<a class="headerlink" href="#integration-flow" title="Permanent link">&para;</a></h3>
<p>MAZE integrates with four external systems:</p>
<ol>
<li><strong>llguidance</strong> (Microsoft Research): Constraint enforcement during decoding</li>
<li><strong>mnemosyne</strong>: Persistent memory for pattern learning across sessions</li>
<li><strong>RUNE</strong>: Sandboxed execution for safe test validation</li>
<li><strong>pedantic_raven</strong>: Deep semantic validation (planned integration)</li>
</ol>
<h2 id="4-4-tier-constraint-system">4. 4-Tier Constraint System<a class="headerlink" href="#4-4-tier-constraint-system" title="Permanent link">&para;</a></h2>
<p>MAZE's core innovation is a hierarchical constraint system that progressively narrows the space of valid programs:</p>
<h3 id="tier-1-syntactic-constraints-cfg-grammars">Tier 1: Syntactic Constraints (CFG Grammars)<a class="headerlink" href="#tier-1-syntactic-constraints-cfg-grammars" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Ensure generated code is syntactically valid</p>
<p><strong>Implementation</strong>: Context-Free Grammars (CFG) in Lark format</p>
<p><strong>Status</strong>: ‚úÖ Complete for TypeScript, partial for Python/Rust</p>
<p><strong>Benefits</strong>:</p>
<ul>
<li><strong>Guaranteed syntactic validity</strong>: Generated code always parses</li>
<li><strong>Language-aware generation</strong>: LLM respects language syntax rules</li>
<li><strong>Composability</strong>: Grammars can be combined and extended</li>
</ul>
<h3 id="tier-2-type-constraints-inhabitation-search">Tier 2: Type Constraints (Inhabitation Search)<a class="headerlink" href="#tier-2-type-constraints-inhabitation-search" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Ensure generated code is type-correct</p>
<p><strong>Implementation</strong>: Type inhabitation solver + type-to-grammar conversion</p>
<p><strong>Status</strong>: ‚úÖ Complete</p>
<p><strong>Research Foundation</strong>: M√ºndler et al., "Type-Constrained Code Generation" (PLDI 2025, arXiv:2504.09246)</p>
<h4 id="key-concept-type-inhabitation">Key Concept: Type Inhabitation<a class="headerlink" href="#key-concept-type-inhabitation" title="Permanent link">&para;</a></h4>
<p>Given a source type <code>S</code> and target type <code>T</code>, find valid transformation paths.</p>
<p><strong>Example</strong>: Finding <code>User ‚Üí string</code> paths</p>
<p>Given:</p>
<div class="highlight"><pre><span></span><code><span class="kd">interface</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>
<span class="w">  </span><span class="nx">toString</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Valid paths:</p>
<ol>
<li><code>user.id</code> ‚Üí <code>string</code> ‚úÖ (property access)</li>
<li><code>user.name</code> ‚Üí <code>string</code> ‚úÖ (property access)</li>
<li><code>user.email</code> ‚Üí <code>string</code> ‚úÖ (property access)</li>
<li><code>user.toString()</code> ‚Üí <code>string</code> ‚úÖ (method call)</li>
</ol>
<p>Invalid paths:</p>
<ul>
<li><code>user.age</code> ‚Üí <code>string</code> ‚ùå (type mismatch: number ‚Üí string)</li>
<li><code>user</code> ‚Üí <code>string</code> ‚ùå (no direct conversion)</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li><strong>Type safety</strong>: Generated code is type-correct by construction</li>
<li><strong>Error reduction</strong>: Eliminates type errors that plague unconstrained generation</li>
<li><strong>Contextual awareness</strong>: Leverages project's type hierarchy</li>
</ul>
<h3 id="tier-3-semantic-constraints-test-driven">Tier 3: Semantic Constraints (Test-Driven)<a class="headerlink" href="#tier-3-semantic-constraints-test-driven" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Ensure generated code implements specified behavior</p>
<p><strong>Implementation</strong>: Test cases + property specifications</p>
<p><strong>Status</strong>: ‚úÖ Validators complete, orchestration planned</p>
<p>Semantic constraints are specified through:</p>
<ol>
<li><strong>Concrete test cases</strong>: Input/output examples</li>
<li><strong>Property-based constraints</strong>: Invariants that must hold</li>
</ol>
<p><strong>Integration with RUNE</strong>: All test execution happens in RUNE sandboxes to ensure network isolation, filesystem isolation, resource limits, and deterministic execution.</p>
<h3 id="tier-4-contextual-constraints-learned">Tier 4: Contextual Constraints (Learned)<a class="headerlink" href="#tier-4-contextual-constraints-learned" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Ensure generated code matches project conventions and patterns</p>
<p><strong>Implementation</strong>: Pattern mining + mnemosyne integration</p>
<p><strong>Status</strong>: üìã Planned (Phase 5)</p>
<p>Projects have implicit conventions that go beyond syntax, types, and semantics:</p>
<ul>
<li>Naming conventions (camelCase, PascalCase, snake_case)</li>
<li>Error handling patterns (try/catch, Result types, null checks)</li>
<li>Async patterns (async/await vs. .then(), Promise usage)</li>
<li>Import organization (alphabetical, grouped by source)</li>
</ul>
<h3 id="constraint-composition">Constraint Composition<a class="headerlink" href="#constraint-composition" title="Permanent link">&para;</a></h3>
<p>The four tiers compose hierarchically:</p>
<div class="highlight"><pre><span></span><code><span class="nx">Syntactic</span><span class="w"> </span><span class="nx">constraints</span><span class="w"> </span><span class="p">(</span><span class="nx">broadest</span><span class="p">)</span>
<span class="w">  </span><span class="err">‚Üì</span><span class="w"> </span><span class="nx">Narrows</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">syntactically</span><span class="w"> </span><span class="nx">valid</span><span class="w"> </span><span class="nx">programs</span>
<span class="nx">Type</span><span class="w"> </span><span class="nx">constraints</span>
<span class="w">  </span><span class="err">‚Üì</span><span class="w"> </span><span class="nx">Narrows</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="k">type</span><span class="o">-</span><span class="nx">correct</span><span class="w"> </span><span class="nx">programs</span>
<span class="nx">Semantic</span><span class="w"> </span><span class="nx">constraints</span>
<span class="w">  </span><span class="err">‚Üì</span><span class="w"> </span><span class="nx">Narrows</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">behaviorally</span><span class="w"> </span><span class="nx">correct</span><span class="w"> </span><span class="nx">programs</span>
<span class="nx">Contextual</span><span class="w"> </span><span class="nx">constraints</span>
<span class="w">  </span><span class="err">‚Üì</span><span class="w"> </span><span class="nx">Narrows</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">project</span><span class="o">-</span><span class="nx">conformant</span><span class="w"> </span><span class="nx">programs</span>
</code></pre></div>

<h2 id="5-type-directed-synthesis">5. Type-Directed Synthesis<a class="headerlink" href="#5-type-directed-synthesis" title="Permanent link">&para;</a></h2>
<p>Type-directed synthesis is MAZE's most sophisticated capability, enabling generation of type-correct code through formal type theory.</p>
<p><strong>Research Foundation</strong>: M√ºndler et al. (PLDI 2025) and Blinn et al. (OOPSLA 2024)</p>
<h3 id="bidirectional-type-inference">Bidirectional Type Inference<a class="headerlink" href="#bidirectional-type-inference" title="Permanent link">&para;</a></h3>
<p>MAZE implements bidirectional type inference to propagate type information in both directions:</p>
<ul>
<li><strong>Synthesis mode</strong> (bottom-up): Infer type of expression from sub-expressions</li>
<li><strong>Checking mode</strong> (top-down): Check if expression matches expected type</li>
</ul>
<h3 id="type-inhabitation-solver">Type Inhabitation Solver<a class="headerlink" href="#type-inhabitation-solver" title="Permanent link">&para;</a></h3>
<p><strong>Purpose</strong>: Find expressions that inhabit (produce) a given type</p>
<p><strong>Optimization Techniques</strong>:</p>
<ol>
<li><strong>Memoization</strong>: Cache results to avoid redundant searches</li>
<li><strong>Depth limiting</strong>: Prevent infinite recursion (default: max_depth=5)</li>
<li><strong>Ranking</strong>: Prioritize simpler expressions (fewer steps)</li>
<li><strong>Pruning</strong>: Eliminate type-incompatible paths early</li>
</ol>
<h3 id="typed-hole-filling">Typed Hole Filling<a class="headerlink" href="#typed-hole-filling" title="Permanent link">&para;</a></h3>
<p><strong>Research Foundation</strong>: Blinn et al., "Statically Contextualizing LLMs with Typed Holes" (OOPSLA 2024, arXiv:2409.00921)</p>
<p><strong>Concept</strong>: Partial code with "holes" to be filled</p>
<p><strong>Example</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">getUserEmail</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetchUser</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">user</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/*__HOLE__*/</span><span class="w">  </span><span class="c1">// What should we return here?</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="cm">/*__HOLE__*/</span><span class="p">;</span><span class="w">  </span><span class="c1">// What expression returns string from User?</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="6-integration-ecosystem">6. Integration Ecosystem<a class="headerlink" href="#6-integration-ecosystem" title="Permanent link">&para;</a></h2>
<h3 id="llguidance-constraint-enforcement">llguidance: Constraint Enforcement<a class="headerlink" href="#llguidance-constraint-enforcement" title="Permanent link">&para;</a></h3>
<p><strong>Source</strong>: Microsoft Research, <a href="https://github.com/guidance-ai/llguidance">guidance-ai/llguidance</a></p>
<p><strong>Purpose</strong>: Efficient constraint enforcement during LLM decoding</p>
<p><strong>Performance</strong> (upstream benchmarks):</p>
<ul>
<li>Mask computation: ~50Œºs per token (p99, 128k tokenizer)</li>
<li>Grammar compilation: &lt;50ms for typical programming language grammars</li>
<li>Memory overhead: ~10MB per grammar automaton</li>
</ul>
<h3 id="mnemosyne-persistent-memory">mnemosyne: Persistent Memory<a class="headerlink" href="#mnemosyne-persistent-memory" title="Permanent link">&para;</a></h3>
<p><strong>Source</strong>: <a href="https://github.com/rand/mnemosyne">rand/mnemosyne</a>, <a href="https://rand.github.io/mnemosyne">Documentation</a></p>
<p><strong>Purpose</strong>: Semantic memory and learning across sessions</p>
<p><strong>Status</strong>: ‚úÖ Basic integration complete, full adaptive learning planned (Phase 5)</p>
<h3 id="rune-sandboxed-execution">RUNE: Sandboxed Execution<a class="headerlink" href="#rune-sandboxed-execution" title="Permanent link">&para;</a></h3>
<p><strong>Source</strong>: <a href="https://github.com/rand/RUNE">rand/RUNE</a>, <a href="https://rand.github.io/RUNE">Documentation</a></p>
<p><strong>Purpose</strong>: Safe, isolated execution for test validation</p>
<p><strong>Safety Guarantees</strong>:</p>
<ul>
<li><strong>Network isolation</strong>: No external network access</li>
<li><strong>Filesystem isolation</strong>: Temporary directory only</li>
<li><strong>Resource limits</strong>: CPU, memory, and time quotas enforced</li>
<li><strong>Deterministic execution</strong>: Same input ‚Üí same output</li>
</ul>
<p><strong>Status</strong>: ‚úÖ Complete integration via RuneExecutor</p>
<h3 id="pedantic_raven-quality-enforcement">pedantic_raven: Quality Enforcement<a class="headerlink" href="#pedantic_raven-quality-enforcement" title="Permanent link">&para;</a></h3>
<p><strong>Source</strong>: <a href="https://github.com/rand/pedantic_raven">rand/pedantic_raven</a></p>
<p><strong>Status</strong>: üìã Placeholder exists, full integration planned (Phase 4/5)</p>
<h2 id="7-implementation-status-and-roadmap">7. Implementation Status and Roadmap<a class="headerlink" href="#7-implementation-status-and-roadmap" title="Permanent link">&para;</a></h2>
<h3 id="current-status-active-development">Current Status: Active Development<a class="headerlink" href="#current-status-active-development" title="Permanent link">&para;</a></h3>
<p>MAZE has completed its core architectural foundation (Phases 1-3) and is actively building the validation and repair pipeline (Phase 4).</p>
<h3 id="phase-1-3-core-system-complete">Phase 1-3: Core System ‚úÖ COMPLETE<a class="headerlink" href="#phase-1-3-core-system-complete" title="Permanent link">&para;</a></h3>
<p><strong>10,847 lines of code across 43 source files</strong></p>
<h4 id="phase-1-foundation">Phase 1: Foundation<a class="headerlink" href="#phase-1-foundation" title="Permanent link">&para;</a></h4>
<ul>
<li>‚úÖ Core type system</li>
<li>‚úÖ Constraint abstractions</li>
<li>‚úÖ llguidance integration</li>
<li>‚úÖ TypeScript indexer</li>
<li>‚úÖ Test infrastructure (29 test files)</li>
</ul>
<h4 id="phase-2-syntactic-synthesis">Phase 2: Syntactic Synthesis<a class="headerlink" href="#phase-2-syntactic-synthesis" title="Permanent link">&para;</a></h4>
<ul>
<li>‚úÖ Grammar builder</li>
<li>‚úÖ JSON Schema builder</li>
<li>‚úÖ Provider adapters</li>
<li>‚úÖ Language grammars: TypeScript (complete), Python/Rust (partial)</li>
</ul>
<h4 id="phase-3-type-system">Phase 3: Type System<a class="headerlink" href="#phase-3-type-system" title="Permanent link">&para;</a></h4>
<p><strong>2,124 lines dedicated to type system</strong></p>
<ul>
<li>‚úÖ Type inference engine</li>
<li>‚úÖ Type inhabitation solver</li>
<li>‚úÖ Typed holes</li>
<li>‚úÖ Type-to-grammar converter</li>
<li>‚úÖ TypeScript type system</li>
</ul>
<h3 id="phase-4-validation-repair-in-progress-610-complete">Phase 4: Validation &amp; Repair üöß IN PROGRESS (6/10 complete)<a class="headerlink" href="#phase-4-validation-repair-in-progress-610-complete" title="Permanent link">&para;</a></h3>
<p><strong>Recent Progress</strong> (as of November 8, 2025):</p>
<p>‚úÖ <strong>Complete Components</strong>:</p>
<ol>
<li>SyntaxValidator - Commit 013846c</li>
<li>TypeValidator - Commit a1b463c</li>
<li>TestValidator - Commit 3f8f006</li>
<li>LintValidator - Commit 7a91e04</li>
<li>RuneExecutor - Commit 0e358b4</li>
<li>ValidationPipeline - Commit b4b31c6</li>
</ol>
<p>üìã <strong>Remaining Tasks</strong>:</p>
<ul>
<li>RepairOrchestrator: Manages repair iteration logic</li>
<li>DiagnosticAnalyzer: Interprets validation failures</li>
<li>ConstraintRefinement: Tightens constraints based on diagnostics</li>
<li>Full pedantic_raven integration: Deep semantic validation</li>
</ul>
<p><strong>Expected Completion</strong>: December 2025</p>
<h3 id="phase-5-adaptive-learning-planned">Phase 5: Adaptive Learning üìã PLANNED<a class="headerlink" href="#phase-5-adaptive-learning-planned" title="Permanent link">&para;</a></h3>
<p><strong>Timeline</strong>: Q1 2026</p>
<ul>
<li>Pattern mining from existing codebases</li>
<li>Constraint learning from generation outcomes</li>
<li>Full mnemosyne integration for persistent learning</li>
<li>Project-specific pattern adaptation</li>
</ul>
<h3 id="phase-6-production-planned">Phase 6: Production üìã PLANNED<a class="headerlink" href="#phase-6-production-planned" title="Permanent link">&para;</a></h3>
<p><strong>Timeline</strong>: Q2 2026</p>
<ul>
<li>Performance optimization (speculative decoding, parallelization)</li>
<li>Multi-language indexers (Python, Rust, Go, Zig completion)</li>
<li>IDE integrations (VSCode, IntelliJ plugins)</li>
<li>Comprehensive benchmarking: HumanEval, MBPP, SWE-bench-lite</li>
<li>Production deployment guides</li>
</ul>
<h2 id="8-research-foundation">8. Research Foundation<a class="headerlink" href="#8-research-foundation" title="Permanent link">&para;</a></h2>
<p>MAZE builds on established research in constrained generation, program synthesis, and type theory:</p>
<h3 id="type-constrained-code-generation-pldi-2025">Type-Constrained Code Generation (PLDI 2025)<a class="headerlink" href="#type-constrained-code-generation-pldi-2025" title="Permanent link">&para;</a></h3>
<p><strong>Paper</strong>: M√ºndler et al., "Type-Constrained Code Generation with Language Models"</p>
<p><strong>Venue</strong>: PLDI 2025</p>
<p><strong>arXiv</strong>: <a href="https://arxiv.org/abs/2504.09246">2504.09246</a></p>
<p><strong>Key Contributions</strong>:</p>
<ol>
<li>Type constraints as prefix automata</li>
<li>Bidirectional type inference for LLM guidance</li>
<li>Reported &gt;50% reduction in compilation errors</li>
</ol>
<h3 id="statically-contextualizing-llms-with-typed-holes-oopsla-2024">Statically Contextualizing LLMs with Typed Holes (OOPSLA 2024)<a class="headerlink" href="#statically-contextualizing-llms-with-typed-holes-oopsla-2024" title="Permanent link">&para;</a></h3>
<p><strong>Paper</strong>: Blinn et al., "Statically Contextualizing Large Language Models with Typed Holes"</p>
<p><strong>Venue</strong>: OOPSLA 2024</p>
<p><strong>arXiv</strong>: <a href="https://arxiv.org/abs/2409.00921">2409.00921</a></p>
<p><strong>Key Contributions</strong>:</p>
<ol>
<li>Typed holes for partial code completion</li>
<li>Static context extraction for LLM guidance</li>
<li>Evaluation on real-world TypeScript codebases</li>
</ol>
<h3 id="llguidance-constraint-enforcement-for-llms">LLGuidance: Constraint Enforcement for LLMs<a class="headerlink" href="#llguidance-constraint-enforcement-for-llms" title="Permanent link">&para;</a></h3>
<p><strong>Source</strong>: Microsoft Research, <a href="https://github.com/guidance-ai/llguidance">guidance-ai/llguidance</a></p>
<p><strong>Key Contributions</strong>:</p>
<ol>
<li>Efficient CFG grammar enforcement during decoding</li>
<li>Sub-100Œºs token mask computation</li>
<li>Provider-agnostic integration</li>
</ol>
<h2 id="9-architecture-validation">9. Architecture Validation<a class="headerlink" href="#9-architecture-validation" title="Permanent link">&para;</a></h2>
<p>All claims in this whitepaper are validated against the codebase at tag <code>v0.1.0-whitepaper</code>.</p>
<h3 id="code-statistics">Code Statistics<a class="headerlink" href="#code-statistics" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Total source files</td>
<td>43</td>
</tr>
<tr>
<td>Total source lines</td>
<td>10,847</td>
</tr>
<tr>
<td>Test files</td>
<td>29</td>
</tr>
<tr>
<td>Type system lines</td>
<td>2,124</td>
</tr>
</tbody>
</table>
<h3 id="component-verification">Component Verification<a class="headerlink" href="#component-verification" title="Permanent link">&para;</a></h3>
<p>All components link to tagged source code at <code>v0.1.0-whitepaper</code> for verification:</p>
<ul>
<li><strong>Core Type System</strong> ‚úÖ: <a href="https://github.com/rand/maze/tree/v0.1.0-whitepaper/src/maze/core/types.py">types.py</a>, <a href="https://github.com/rand/maze/tree/v0.1.0-whitepaper/src/maze/core/constraints.py">constraints.py</a></li>
<li><strong>Type System</strong> ‚úÖ (2,124 lines): Multiple modules in <a href="https://github.com/rand/maze/tree/v0.1.0-whitepaper/src/maze/type_system/">type_system/</a></li>
<li><strong>Synthesis</strong> ‚úÖ: <a href="https://github.com/rand/maze/tree/v0.1.0-whitepaper/src/maze/synthesis/">synthesis/</a></li>
<li><strong>Validation</strong> ‚úÖ: <a href="https://github.com/rand/maze/tree/v0.1.0-whitepaper/src/maze/validation/">validation/</a></li>
<li><strong>Integrations</strong> ‚úÖ: llguidance, mnemosyne, RUNE in <a href="https://github.com/rand/maze/tree/v0.1.0-whitepaper/src/maze/integrations/">integrations/</a></li>
</ul>
<h2 id="10-getting-started">10. Getting Started<a class="headerlink" href="#10-getting-started" title="Permanent link">&para;</a></h2>
<h3 id="installation">Installation<a class="headerlink" href="#installation" title="Permanent link">&para;</a></h3>
<p>MAZE requires Python 3.10+ and uses <code>uv</code> for dependency management:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Clone repository</span>
git<span class="w"> </span>clone<span class="w"> </span>https://github.com/rand/maze
<span class="nb">cd</span><span class="w"> </span>maze

<span class="c1"># Install dependencies</span>
uv<span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>-e<span class="w"> </span><span class="s2">&quot;.[dev]&quot;</span>

<span class="c1"># Verify installation</span>
uv<span class="w"> </span>run<span class="w"> </span>python<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;import maze; print(&#39;MAZE installed successfully&#39;)&quot;</span>
</code></pre></div>

<h3 id="basic-usage-conceptual">Basic Usage (Conceptual)<a class="headerlink" href="#basic-usage-conceptual" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">maze.core.constraints</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConstraintSet</span><span class="p">,</span> <span class="n">SyntacticConstraint</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">maze.type_system.context</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeContext</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">maze.orchestrator</span><span class="w"> </span><span class="kn">import</span> <span class="n">generate</span>

<span class="c1"># 1. Define constraints</span>
<span class="n">constraints</span> <span class="o">=</span> <span class="n">ConstraintSet</span><span class="p">()</span>
<span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SyntacticConstraint</span><span class="o">.</span><span class="n">from_language</span><span class="p">(</span><span class="s2">&quot;typescript&quot;</span><span class="p">))</span>

<span class="c1"># 2. Optionally add type context</span>
<span class="n">type_context</span> <span class="o">=</span> <span class="n">TypeContext</span><span class="p">()</span>
<span class="n">type_context</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s2">&quot;User&quot;</span><span class="p">,</span> <span class="p">{</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
    <span class="s2">&quot;email&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span>
<span class="p">})</span>

<span class="c1"># 3. Generate code</span>
<span class="n">code</span> <span class="o">=</span> <span class="n">generate</span><span class="p">(</span>
    <span class="n">prompt</span><span class="o">=</span><span class="s2">&quot;Create an async function that fetches a user by ID and returns their email&quot;</span><span class="p">,</span>
    <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
    <span class="n">type_context</span><span class="o">=</span><span class="n">type_context</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
</code></pre></div>

<h2 id="11-conclusion">11. Conclusion<a class="headerlink" href="#11-conclusion" title="Permanent link">&para;</a></h2>
<h3 id="summary-of-contributions">Summary of Contributions<a class="headerlink" href="#summary-of-contributions" title="Permanent link">&para;</a></h3>
<p>MAZE introduces a novel approach to code generation that shifts from post-hoc validation to pre-generation constraint enforcement:</p>
<ol>
<li><strong>4-Tier Constraint Hierarchy</strong>: Progressive constraint tightening from syntax through types, semantics, and context</li>
<li><strong>Type-Directed Synthesis</strong>: Bidirectional type inference and inhabitation search for type-correct code paths</li>
<li><strong>Multi-System Integration</strong>: Seamless integration with llguidance, mnemosyne, RUNE, and pedantic_raven</li>
<li><strong>Research-Backed Design</strong>: Built on PLDI 2025 and OOPSLA 2024 research</li>
<li><strong>Provider-Agnostic Architecture</strong>: Support for OpenAI, vLLM, SGLang, and llama.cpp</li>
</ol>
<h3 id="current-state-solid-foundation">Current State: Solid Foundation<a class="headerlink" href="#current-state-solid-foundation" title="Permanent link">&para;</a></h3>
<p>With 10,847 lines of code across 43 source files, MAZE has completed its core architectural foundation:</p>
<ul>
<li><strong>Phase 1-3</strong>: Type system, constraint synthesis, and core integrations complete</li>
<li><strong>Phase 4</strong>: Validation pipeline 60% complete (6/10 tasks)</li>
<li><strong>Phase 5-6</strong>: Adaptive learning and production hardening planned</li>
</ul>
<h3 id="future-work">Future Work<a class="headerlink" href="#future-work" title="Permanent link">&para;</a></h3>
<p><strong>Short Term</strong> (Phase 4, Q4 2025):</p>
<ul>
<li>Complete repair orchestrator</li>
<li>Diagnostic analyzer for intelligent constraint refinement</li>
<li>Full pedantic_raven integration</li>
</ul>
<p><strong>Medium Term</strong> (Phase 5, Q1 2026):</p>
<ul>
<li>Pattern mining from codebases</li>
<li>Adaptive constraint learning</li>
<li>Project-specific pattern adaptation</li>
</ul>
<p><strong>Long Term</strong> (Phase 6, Q2 2026):</p>
<ul>
<li>Multi-language indexer completion (Python, Rust, Go, Zig)</li>
<li>Comprehensive benchmark evaluation (HumanEval, MBPP, SWE-bench)</li>
<li>IDE integrations (VSCode, IntelliJ)</li>
<li>Production deployment optimization</li>
</ul>
<h2 id="12-resources">12. Resources<a class="headerlink" href="#12-resources" title="Permanent link">&para;</a></h2>
<h3 id="project-links">Project Links<a class="headerlink" href="#project-links" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>GitHub Repository</strong>: <a href="https://github.com/rand/maze">github.com/rand/maze</a></li>
<li><strong>Documentation</strong>: <a href="CLAUDE.md">CLAUDE.md</a>, <a href="AGENT_GUIDE.md">AGENT_GUIDE.md</a></li>
<li><strong>Whitepaper</strong>: <a href="https://rand.github.io/maze">maze whitepaper</a></li>
</ul>
<h3 id="research-papers">Research Papers<a class="headerlink" href="#research-papers" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Type-Constrained Code Generation</strong>: <a href="https://arxiv.org/abs/2504.09246">arXiv:2504.09246</a> (PLDI 2025)</li>
<li><strong>Typed Holes</strong>: <a href="https://arxiv.org/abs/2409.00921">arXiv:2409.00921</a> (OOPSLA 2024)</li>
</ul>
<h3 id="related-projects">Related Projects<a class="headerlink" href="#related-projects" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>llguidance</strong>: <a href="https://github.com/guidance-ai/llguidance">github.com/guidance-ai/llguidance</a> (Microsoft Research)</li>
<li><strong>mnemosyne</strong>: <a href="https://rand.github.io/mnemosyne">rand.github.io/mnemosyne</a> (Memory &amp; Learning)</li>
<li><strong>RUNE</strong>: <a href="https://rand.github.io/RUNE">rand.github.io/RUNE</a> (Sandboxed Execution)</li>
</ul>
<hr />
<p><strong>Version</strong>: v0.1.0-whitepaper
<strong>Last Updated</strong>: November 2025
<strong>License</strong>: [To be determined]</p>

<footer class="footer">
    <p>
        MAZE is open-source software. For questions or contributions, visit the
        <a href="https://github.com/rand/maze">GitHub repository</a>.
    </p>
</footer>

    </main>

    <script src="js/theme.js"></script>
    <script src="js/sidebar.js"></script>
</body>
</html>