{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"MAZE: Adaptive Constrained Code Generation","text":"<p>A research-backed system for type-correct, semantically sound code generation</p> <p>Version: v0.1.0-whitepaper Date: November 2025 Repository: github.com/rand/maze</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#abstract","level":2,"title":"Abstract","text":"<p>Large Language Models demonstrate remarkable code generation capabilities, yet suffer from high error rates when generating complex, type-correct code. Unconstrained generation produces syntactically valid but semantically incorrect or type-unsafe code, requiring expensive post-hoc validation and multiple repair iterations.</p> <p>MAZE introduces a paradigm shift: compile constraints before decoding, rather than hoping for correctness after generation. Through a novel 4-tier constraint hierarchy—syntactic (CFG grammars), type (inhabitation search), semantic (test-driven), and contextual (learned patterns)—MAZE guides LLM generation toward valid, type-correct, and project-conformant code from the start.</p> <p>Built on research from PLDI 2025 (Type-Constrained Code Generation) and OOPSLA 2024 (Typed Holes), MAZE integrates with multiple LLM providers (OpenAI, vLLM, SGLang, llama.cpp) through llguidance for constraint enforcement, mnemosyne for persistent learning, and RUNE for sandboxed validation.</p> <p>Current status: Core constraint system complete (Phases 1-3), validation pipeline in active development (Phase 4: 6/10 tasks complete), with adaptive learning and production hardening planned (Phases 5-6).</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#the-paradigm-shift","level":2,"title":"The Paradigm Shift","text":"","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#traditional-approach-generate-then-fix","level":3,"title":"Traditional Approach: Generate, Then Fix","text":"<pre><code>Generate (unconstrained) → Validate → Find errors → Fix → Repeat\n# 3-5 iterations common\n# High latency, token waste, context overflow\n</code></pre>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#maze-approach-constrain-then-generate","level":3,"title":"MAZE Approach: Constrain, Then Generate","text":"<pre><code>Build constraints → Generate (constrained) → Minimal validation → Done\n# Correct by construction\n# Single iteration, predictable cost\n</code></pre> <p>By enforcing constraints during decoding rather than after generation, MAZE reduces error rates, minimizes repair iterations, and produces higher-quality code with less computational overhead.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#architecture","level":2,"title":"Architecture","text":"<p>MAZE's architecture consists of five integrated stages that transform a code generation request into validated, type-correct code.</p> <p></p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#stage-1-context-indexer","level":3,"title":"Stage 1: Context Indexer","text":"<p>Purpose: Extract structured information from source code to inform constraint synthesis</p> <p>Status: Complete for TypeScript; Python, Rust, Go, Zig planned</p> <ul> <li>Extracts functions, classes, interfaces, type aliases</li> <li>Parses type annotations and generic parameters</li> <li>Detects project style and test patterns</li> </ul>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#stage-2-constraint-synthesis","level":3,"title":"Stage 2: Constraint Synthesis","text":"<p>Purpose: Build hierarchical constraints from indexed context and generation request</p> <p>Status: Complete</p> <ul> <li>GrammarBuilder: Generates CFG grammars in Lark format</li> <li>TypeToGrammarConverter: Converts type constraints into grammar rules</li> <li>SchemaBuilder: Generates JSON Schema for OpenAI compatibility</li> </ul>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#stage-3-decode-orchestrator","level":3,"title":"Stage 3: Decode Orchestrator","text":"<p>Purpose: Generate code under constraints using provider-specific adapters</p> <p>Status: Complete (OpenAI, vLLM, SGLang, llama.cpp)</p> <p>Integration with llguidance for token-level constraint enforcement. Upstream performance: approximately 50μs per token mask computation.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#stage-4-post-validation","level":3,"title":"Stage 4: Post-Validation","text":"<p>Purpose: Validate generated code across multiple dimensions in parallel</p> <p>Status: 60 percent complete (6 of 10 tasks)</p> <ul> <li>SyntaxValidator: Language-specific syntax checking</li> <li>TypeValidator: Type checking via compiler APIs</li> <li>TestValidator: RUNE sandbox test execution</li> <li>LintValidator: Style and quality checking</li> <li>ValidationPipeline: Parallel validation orchestration</li> <li>RepairOrchestrator, DiagnosticAnalyzer, ConstraintRefinement in progress</li> </ul>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#stage-5-repair-loop","level":3,"title":"Stage 5: Repair Loop","text":"<p>Purpose: Refine constraints and regenerate if validation fails</p> <p>Status: Planned (Phase 4)</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#4-tier-constraint-system","level":2,"title":"4-Tier Constraint System","text":"<p>MAZE's core innovation is a hierarchical constraint system that progressively narrows the space of valid programs.</p> <p></p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#tier-1-syntactic-constraints","level":3,"title":"Tier 1: Syntactic Constraints","text":"<p>Implementation: Context-Free Grammars</p> <p>Status: TypeScript complete, Python and Rust partial</p> <p>Ensures generated code is syntactically valid through CFG grammars integrated with llguidance for token-level enforcement during decoding.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#tier-2-type-constraints","level":3,"title":"Tier 2: Type Constraints","text":"<p>Implementation: Type Inhabitation Search</p> <p>Status: Complete (2,124 lines)</p> <p>Research Foundation: Mündler et al., PLDI 2025</p> <p>Given source type S and target type T, finds valid transformation paths through property access, method calls, and function applications to construct type-correct expressions.</p> <p></p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#tier-3-semantic-constraints","level":3,"title":"Tier 3: Semantic Constraints","text":"<p>Implementation: Test-Driven Validation</p> <p>Status: Validators complete, orchestration planned</p> <p>Ensures generated code implements specified behavior through concrete test cases and property-based invariants. All test execution happens in RUNE sandboxes for safety isolation.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#tier-4-contextual-constraints","level":3,"title":"Tier 4: Contextual Constraints","text":"<p>Implementation: Learned Patterns</p> <p>Status: Planned (Phase 5)</p> <p>Ensures generated code matches project conventions through pattern mining. Integrated with mnemosyne for persistent learning across sessions.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#integration-ecosystem","level":2,"title":"Integration Ecosystem","text":"<p>MAZE integrates with four external systems, each providing complementary capabilities.</p> <p></p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#llguidance-microsoft-research","level":3,"title":"llguidance (Microsoft Research)","text":"<p>Status: Complete</p> <p>Efficient constraint enforcement during LLM decoding. Compiles CFG grammars into finite-state automata for token-level masking. Performance: approximately 50μs per token (p99), grammar compilation under 50ms.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#mnemosyne-persistent-memory","level":3,"title":"mnemosyne (Persistent Memory)","text":"<p>Status: Basic integration complete</p> <p>Semantic memory and learning across sessions. Stores successful constraint patterns, recalls relevant contexts for new tasks, updates pattern weights based on outcomes.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#rune-sandboxed-execution","level":3,"title":"RUNE (Sandboxed Execution)","text":"<p>Status: Complete</p> <p>Safe, isolated execution for test validation with network isolation, filesystem isolation, and resource limits. Deterministic execution ensures same input produces same output.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#pedantic_raven-quality-enforcement","level":3,"title":"pedantic_raven (Quality Enforcement)","text":"<p>Status: Planned</p> <p>Deep semantic validation and code quality checks beyond syntax and types.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#implementation-status","level":2,"title":"Implementation Status","text":"","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#phases-1-3-core-system-complete","level":3,"title":"Phases 1-3: Core System (Complete)","text":"<p>10,847 lines across 43 source files; 2,124 lines type system</p> <ul> <li>Core type system and constraint abstractions</li> <li>TypeScript indexer with full symbol extraction</li> <li>Grammar builder, schema builder, provider adapters</li> <li>Type inference, inhabitation solver, typed holes</li> <li>llguidance and mnemosyne integration</li> </ul>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#phase-4-validation-and-repair-60-percent-complete","level":3,"title":"Phase 4: Validation and Repair (60 percent complete)","text":"<p>Recent Progress (as of November 8, 2025):</p> <ul> <li>SyntaxValidator: Language-specific syntax checking</li> <li>TypeValidator: Type checking via TypeScript compiler API</li> <li>TestValidator: RUNE sandbox test execution</li> <li>LintValidator: ESLint, Ruff, Clippy integration</li> <li>ValidationPipeline: Parallel validation orchestration</li> <li>RuneExecutor: Safe sandboxed execution</li> <li>RepairOrchestrator, DiagnosticAnalyzer, ConstraintRefinement in progress</li> </ul> <p>Expected Completion: December 2025</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#phase-5-adaptive-learning-planned","level":3,"title":"Phase 5: Adaptive Learning (Planned)","text":"<p>Timeline: Q1 2026</p> <ul> <li>Pattern mining from existing codebases</li> <li>Constraint learning from generation outcomes</li> <li>Full mnemosyne integration for persistent learning</li> <li>Project-specific pattern adaptation</li> </ul>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#phase-6-production-planned","level":3,"title":"Phase 6: Production (Planned)","text":"<p>Timeline: Q2 2026</p> <ul> <li>Performance optimization (speculative decoding, parallelization)</li> <li>Multi-language indexers (Python, Rust, Go, Zig)</li> <li>IDE integrations (VSCode, IntelliJ)</li> <li>Comprehensive benchmarking (HumanEval, MBPP, SWE-bench)</li> </ul> <p></p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#research-foundation","level":2,"title":"Research Foundation","text":"","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#type-constrained-code-generation-pldi-2025","level":3,"title":"Type-Constrained Code Generation (PLDI 2025)","text":"<p>Paper: Mündler et al.</p> <p>Venue: PLDI 2025</p> <p>arXiv: 2504.09246</p> <p>Type constraints as prefix automata, bidirectional type inference for LLM guidance. Reported reduction of compilation errors by over 50 percent.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#statically-contextualizing-llms-with-typed-holes-oopsla-2024","level":3,"title":"Statically Contextualizing LLMs with Typed Holes (OOPSLA 2024)","text":"<p>Paper: Blinn et al.</p> <p>Venue: OOPSLA 2024</p> <p>arXiv: 2409.00921</p> <p>Typed holes for partial code completion with static context extraction. Evaluation on real-world TypeScript codebases.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#llguidance-microsoft-research_1","level":3,"title":"LLGuidance (Microsoft Research)","text":"<p>Source: github.com/guidance-ai/llguidance</p> <p>Efficient CFG grammar enforcement during decoding. Sub-100μs token mask computation, provider-agnostic integration.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#architecture-validation","level":2,"title":"Architecture Validation","text":"<p>All claims in this whitepaper are validated against the codebase at tag <code>v0.1.0-whitepaper</code>.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#code-statistics","level":3,"title":"Code Statistics","text":"Metric Value Total source files 43 Total source lines 10,847 Test files 29 Type system lines 2,124","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#component-verification","level":3,"title":"Component Verification","text":"<ul> <li>Core Types</li> <li>Type System</li> <li>Synthesis</li> <li>Validation</li> <li>Integrations</li> </ul> <p>Note on Performance Claims: The CHANGELOG.md documents performance achievements. These metrics are documented but the benchmarks directory is currently empty. This whitepaper focuses on architectural design rather than specific performance numbers pending benchmark suite implementation.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#getting-started","level":2,"title":"Getting Started","text":"","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#installation","level":3,"title":"Installation","text":"<pre><code># Clone repository\ngit clone https://github.com/rand/maze\ncd maze\n\n# Install dependencies\nuv pip install -e \".[dev]\"\n\n# Verify installation\nuv run python -c \"import maze; print('MAZE installed successfully')\"\n</code></pre>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"#resources","level":3,"title":"Resources","text":"<ul> <li>Full Whitepaper (Markdown)</li> <li>GitHub Repository</li> <li>Development Guide</li> <li>Tagged Code (v0.1.0-whitepaper)</li> </ul> <p>MAZE is open-source software. For questions or contributions, visit the GitHub repository.</p>","path":["MAZE - Adaptive Constrained Code Generation"],"tags":[]},{"location":"DIAGRAM_REGENERATION/","level":1,"title":"Diagram Regeneration Guide for MAZE","text":"<p>This guide explains how to regenerate diagrams for the MAZE GitHub Pages site.</p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#overview","level":2,"title":"Overview","text":"<p>MAZE uses D2 for diagram generation. Diagrams are stored in <code>docs/whitepaper/diagrams/</code> as <code>.d2</code> source files and rendered to SVG format with both light and dark theme variants.</p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Install D2: <pre><code>curl -fsSL https://d2lang.com/install.sh | sh -s --\n</code></pre></p> <p>Add to your PATH (if not already): <pre><code>export PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre></p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#current-diagram-inventory","level":2,"title":"Current Diagram Inventory","text":"<p>The following diagrams exist in <code>docs/whitepaper/diagrams/</code>: - <code>01-pipeline*.d2</code> - 5-stage processing pipeline - <code>02-constraints*.d2</code> - 4-tier constraint hierarchy - <code>03-type*.d2</code> - Type inhabitation search examples - <code>04-integrations*.d2</code> - Integration ecosystem - <code>06-roadmap*.d2</code> - Development roadmap</p> <p>Some diagrams have <code>-light.d2</code> and <code>-dark.d2</code> variants, others are theme-agnostic.</p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#regeneration-process","level":2,"title":"Regeneration Process","text":"","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#option-1-regenerate-all-diagrams","level":3,"title":"Option 1: Regenerate All Diagrams","text":"<pre><code>cd /Users/rand/src/maze/docs/whitepaper\n\n# Create output directory\nmkdir -p assets/diagrams\n\n# Regenerate all diagrams with light and dark themes\nfor diagram in diagrams/*.d2; do\n  basename=$(basename \"$diagram\" .d2)\n  echo \"Rendering: $basename\"\n\n  # Skip if already a theme variant\n  if [[ \"$basename\" == *-light || \"$basename\" == *-dark ]]; then\n    d2 \"$diagram\" \"assets/diagrams/${basename}.svg\"\n  else\n    # Generate both themes\n    d2 --theme=0 \"$diagram\" \"assets/diagrams/${basename}-light.svg\"\n    d2 --theme=200 \"$diagram\" \"assets/diagrams/${basename}-dark.svg\"\n  fi\ndone\n</code></pre>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#option-2-regenerate-single-diagram","level":3,"title":"Option 2: Regenerate Single Diagram","text":"<pre><code>cd /Users/rand/src/maze/docs/whitepaper\n\n# For a specific diagram (e.g., pipeline)\nd2 --theme=0 diagrams/01-pipeline.d2 assets/diagrams/01-pipeline-light.svg\nd2 --theme=200 diagrams/01-pipeline.d2 assets/diagrams/01-pipeline-dark.svg\n</code></pre>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#option-3-set-up-github-actions-recommended","level":3,"title":"Option 3: Set Up GitHub Actions (Recommended)","text":"<p>Create <code>.github/workflows/deploy-pages.yml</code>:</p> <pre><code>name: Deploy GitHub Pages\n\non:\n  push:\n    branches: [main]\n    paths:\n      - 'docs/**'\n      - '.github/workflows/deploy-pages.yml'\n  workflow_dispatch:\n\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: true\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup D2\n        run: |\n          curl -fsSL https://d2lang.com/install.sh | sh -s --\n          echo \"$HOME/.local/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: Render diagrams\n        run: |\n          cd docs/whitepaper\n          mkdir -p assets/diagrams\n          for diagram in diagrams/*.d2; do\n            basename=$(basename \"$diagram\" .d2)\n            if [[ \"$basename\" != *-light &amp;&amp; \"$basename\" != *-dark ]]; then\n              d2 --theme=0 \"$diagram\" \"assets/diagrams/${basename}-light.svg\"\n              d2 --theme=200 \"$diagram\" \"assets/diagrams/${basename}-dark.svg\"\n            else\n              d2 \"$diagram\" \"assets/diagrams/${basename}.svg\"\n            fi\n          done\n\n      - name: Setup Pages\n        uses: actions/configure-pages@v4\n\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: docs\n\n  deploy:\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    needs: build\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n</code></pre>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#theme-variants","level":2,"title":"Theme Variants","text":"<p>D2 theme options: - <code>--theme=0</code> - Light theme (white background, dark text) - <code>--theme=200</code> - Dark theme (dark background, light text)</p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#diagram-styling-consistency","level":2,"title":"Diagram Styling Consistency","text":"<p>To match RUNE's diagram styling: 1. Use consistent color scheme (orange/amber accent for MAZE) 2. Set proper padding and margins in D2 files 3. Use clear, readable fonts 4. Test both light and dark themes</p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#html-integration","level":2,"title":"HTML Integration","text":"<p>Update HTML to use theme-aware diagram loading:</p> <pre><code>&lt;!-- Option 1: CSS-based theme switching --&gt;\n&lt;div class=\"diagram-container\"&gt;\n    &lt;img class=\"diagram-svg\"\n         alt=\"Pipeline Diagram\"\n         src=\"whitepaper/assets/diagrams/01-pipeline-light.svg\" /&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\nbody.dark-theme .diagram-svg[src*=\"-light.svg\"] {\n    content: url('whitepaper/assets/diagrams/01-pipeline-dark.svg');\n}\n&lt;/style&gt;\n\n&lt;!-- Option 2: Picture element with media queries --&gt;\n&lt;picture&gt;\n    &lt;source srcset=\"whitepaper/assets/diagrams/01-pipeline-dark.svg\"\n            media=\"(prefers-color-scheme: dark)\"&gt;\n    &lt;img src=\"whitepaper/assets/diagrams/01-pipeline-light.svg\"\n         alt=\"Pipeline Diagram\"&gt;\n&lt;/picture&gt;\n</code></pre>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#verification","level":2,"title":"Verification","text":"<p>After regeneration: 1. Check file sizes (should be reasonable, &lt; 200KB per diagram) 2. View in browser with light/dark theme toggle 3. Verify text is readable in both themes 4. Check that colors match MAZE's orange theme (#F59E0B)</p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#troubleshooting","level":2,"title":"Troubleshooting","text":"<p>D2 not found: Ensure <code>~/.local/bin</code> is in your PATH Permission denied: Run <code>chmod +x ~/.local/bin/d2</code> Rendering issues: Check D2 syntax with <code>d2 --help</code> Theme not applying: Verify <code>--theme</code> flag and output filenames</p>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"DIAGRAM_REGENERATION/#references","level":2,"title":"References","text":"<ul> <li>D2 Documentation</li> <li>D2 Themes</li> <li>RUNE Diagram Style Guide</li> </ul>","path":["Diagram Regeneration Guide for MAZE"],"tags":[]},{"location":"architecture/","level":1,"title":"Maze Architecture","text":"<p>This document describes the architecture of the Maze adaptive constrained code generation system.</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#overview","level":2,"title":"Overview","text":"<p>Maze implements a 5-stage pipeline that transforms user prompts into type-safe, validated code through formal constraint enforcement.</p> <pre><code>┌─────────────────────┐\n│   User Input        │\n│ - Prompt            │\n│ - Specification     │\n│ - Context files     │\n└──────────┬──────────┘\n           │\n           ▼\n┌─────────────────────┐\n│ Stage 1:            │\n│ Context Indexer     │◄──── Language-specific indexers\n│ - Extract symbols   │      (TypeScript, Python, etc.)\n│ - Infer types       │\n│ - Detect patterns   │\n└──────────┬──────────┘\n           │\n           ▼\n┌─────────────────────┐\n│ Stage 2:            │\n│ Constraint          │◄──── 4-Tier Hierarchy\n│ Synthesis           │      (Syntactic, Type,\n│ - Build grammars    │       Semantic, Contextual)\n│ - Generate schemas  │\n│ - Define constraints│\n└──────────┬──────────┘\n           │\n           ▼\n┌─────────────────────┐\n│ Stage 3:            │\n│ Decode              │◄──── llguidance integration\n│ Orchestrator        │      Provider adapters\n│ - Generate code     │      (OpenAI, vLLM, etc.)\n│ - Apply constraints │\n│ - Cache masks       │\n└──────────┬──────────┘\n           │\n           ▼\n┌─────────────────────┐\n│ Stage 4:            │\n│ Post-Validation     │◄──── pedantic_raven\n│ - Syntax check      │      RUNE sandbox\n│ - Type check        │\n│ - Run tests         │\n└──────────┬──────────┘\n           │\n           ▼\n┌─────────────────────┐\n│ Stage 5:            │\n│ Repair Loop         │◄──── mnemosyne learning\n│ - Analyze failures  │      Constraint refinement\n│ - Tighten constraints\n│ - Regenerate        │\n└──────────┬──────────┘\n           │\n           ▼\n┌─────────────────────┐\n│   Output            │\n│ - Valid code        │\n│ - Provenance        │\n│ - Metrics           │\n└─────────────────────┘\n</code></pre>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#core-components","level":2,"title":"Core Components","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#1-type-system-srcmazecoretypespy","level":3,"title":"1. Type System (<code>src/maze/core/types.py</code>)","text":"<p>Purpose: Universal type representation across all target languages</p> <p>Key Classes: - <code>Type</code> - Represents types (primitives, generics, functions) - <code>TypeContext</code> - Symbol table with variables, functions, classes - <code>FunctionSignature</code> - Complete function type signatures - <code>ClassType</code> / <code>InterfaceType</code> - Structural types</p> <p>Design Principles: - Language-agnostic representation - Support for generics and higher-kinded types - Nullable type handling - Type substitution for generics</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#2-constraint-system-srcmazecoreconstraintspy","level":3,"title":"2. Constraint System (<code>src/maze/core/constraints.py</code>)","text":"<p>Purpose: Hierarchical constraint enforcement through 4 tiers</p> <p>Constraint Hierarchy:</p> <pre><code>┌────────────────────────────────────────┐\n│  Tier 1: Syntactic Constraints         │\n│  - CFG/Lark grammars                   │\n│  - JSON Schema                         │\n│  - Regex patterns                      │\n│  Performance: &lt;50μs per token          │\n└────────────────────────────────────────┘\n           │\n           ▼\n┌────────────────────────────────────────┐\n│  Tier 2: Type Constraints              │\n│  - Type inhabitation                   │\n│  - Bidirectional inference             │\n│  - Gradual typing                      │\n│  Performance: &lt;1ms per expression      │\n└────────────────────────────────────────┘\n           │\n           ▼\n┌────────────────────────────────────────┐\n│  Tier 3: Semantic Constraints          │\n│  - Property verification               │\n│  - Test execution                      │\n│  - Contract checking                   │\n│  Performance: &lt;500ms per check         │\n└────────────────────────────────────────┘\n           │\n           ▼\n┌────────────────────────────────────────┐\n│  Tier 4: Contextual Constraints        │\n│  - Learned patterns                    │\n│  - Style preferences                   │\n│  - Project conventions                 │\n│  Performance: Soft biases              │\n└────────────────────────────────────────┘\n</code></pre> <p>Key Classes: - <code>Constraint</code> (abstract base) - <code>SyntacticConstraint</code> - Grammar-based constraints - <code>TypeConstraint</code> - Type-driven constraints - <code>SemanticConstraint</code> - Behavioral specifications - <code>ContextualConstraint</code> - Learned soft constraints - <code>ConstraintSet</code> - Hierarchical constraint composition</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#3-llguidance-integration-srcmazeintegrationsllguidance","level":3,"title":"3. LLGuidance Integration (<code>src/maze/integrations/llguidance/</code>)","text":"<p>Purpose: High-performance constraint enforcement via token masking</p> <p>Architecture:</p> <pre><code>┌─────────────────────────────────────────────┐\n│  LLGuidanceAdapter                          │\n│  ┌───────────────────────────────────────┐  │\n│  │  Grammar Cache (1000 entries)         │  │\n│  │  - Content-based hashing              │  │\n│  │  - Lazy compilation                   │  │\n│  └───────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────┐  │\n│  │  Mask Cache (LRU, 100k capacity)      │  │\n│  │  - State + grammar hashing            │  │\n│  │  - &lt;1μs retrieval on hit              │  │\n│  └───────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────┐  │\n│  │  Provider Adapters                    │  │\n│  │  - OpenAI (JSON Schema only)          │  │\n│  │  - vLLM (full CFG support)            │  │\n│  │  - SGLang (native llguidance)         │  │\n│  │  - llama.cpp (grammar support)        │  │\n│  └───────────────────────────────────────┘  │\n└─────────────────────────────────────────────┘\n</code></pre> <p>Performance Characteristics: - Mask computation: 50μs (p99), target &lt;100μs - Grammar compilation: 42ms, target &lt;50ms - Cache hit rate: 89%, target &gt;70% - Memory usage: 600MB, target &lt;1GB</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#4-indexer-framework-srcmazeindexer","level":3,"title":"4. Indexer Framework (<code>src/maze/indexer/</code>)","text":"<p>Purpose: Language-agnostic code analysis and symbol extraction</p> <p>Base Indexer Interface: <pre><code>class BaseIndexer(ABC):\n    @abstractmethod\n    def index_file(self, file_path: Path) -&gt; IndexingResult:\n        \"\"\"Extract symbols from a single file\"\"\"\n\n    @abstractmethod\n    def extract_symbols(self, content: str) -&gt; List[Symbol]:\n        \"\"\"Extract symbols from content\"\"\"\n\n    @abstractmethod\n    def extract_type_context(self, content: str) -&gt; TypeContext:\n        \"\"\"Extract type information\"\"\"\n\n    @abstractmethod\n    def extract_tests(self, content: str) -&gt; List[TestCase]:\n        \"\"\"Extract test cases\"\"\"\n</code></pre></p> <p>Language-Specific Indexers:</p> Language Status Integration Performance TypeScript ✅ Complete tsserver, tree-sitter 1000 symbols/sec Python Planned Pyright, tree-sitter TBD Rust Planned rust-analyzer, tree-sitter TBD Go Planned gopls, tree-sitter TBD Zig Planned zls, tree-sitter TBD <p>Extracted Information: - Symbols (functions, classes, variables) - Type annotations and signatures - Imports and dependencies - Test cases - Style conventions - Constraint candidates (enums, bounds, patterns)</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#5-type-inhabitation-system-planned-phase-3","level":3,"title":"5. Type Inhabitation System (Planned - Phase 3)","text":"<p>Purpose: Find transformation paths from source types to target types</p> <p>Algorithm: Bidirectional type-directed search with memoization</p> <pre><code>Given:\n  source: Type(\"User\")\n  target: Type(\"string\")\n  context: TypeContext with available functions/properties\n\nFind path:\n  User → .name → string\n  User → .email → string\n  User → .toString() → string\n\nRank by:\n  1. Path length (shorter = better)\n  2. Type fitness (exact &gt; compatible &gt; coercible)\n  3. Likelihood (common patterns preferred)\n</code></pre> <p>Performance Targets: - Type search: &lt;1ms (p95) - Search depth: ≤5 (configurable) - Memoization: Cache successful paths</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#integration-architecture","level":2,"title":"Integration Architecture","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#external-system-integration","level":3,"title":"External System Integration","text":"<pre><code>┌─────────────────────────────────────────────────┐\n│  Maze Core                                      │\n│  ┌───────────┐  ┌───────────┐  ┌───────────┐   │\n│  │  Indexer  │  │Constraint │  │Orchestrator│  │\n│  │           │  │ Synthesis │  │           │   │\n│  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘   │\n│        │              │              │         │\n└────────┼──────────────┼──────────────┼─────────┘\n         │              │              │\n    ┌────▼──────┐  ┌────▼──────┐  ┌────▼──────┐\n    │ mnemosyne │  │llguidance │  │  LLM      │\n    │  Memory   │  │ Constraint│  │ Providers │\n    │  System   │  │  Engine   │  │           │\n    └───────────┘  └───────────┘  └───────────┘\n         │                             │\n    ┌────▼──────┐               ┌─────▼─────┐\n    │  Pattern  │               │  OpenAI   │\n    │  Storage  │               │  vLLM     │\n    │  Recall   │               │  SGLang   │\n    └───────────┘               └───────────┘\n\n    ┌───────────────────┐\n    │ pedantic_raven    │\n    │  Validation       │\n    └──────┬────────────┘\n           │\n    ┌──────▼────────────┐\n    │ RUNE Sandbox      │\n    │  Safe Execution   │\n    └───────────────────┘\n</code></pre>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#data-flow","level":3,"title":"Data Flow","text":"<pre><code>1. Prompt + Context → Indexer\n   → Symbols, Types, Patterns\n\n2. Indexed Context → Constraint Synthesis\n   → CFG Grammar, JSON Schema, Type Constraints\n\n3. Prompt + Constraints → Orchestrator\n   → LLM with masked tokens\n\n4. Generated Code → Validation\n   → Syntax, Types, Tests (in RUNE sandbox)\n\n5. Validation Result → Repair Loop\n   → Constraint refinement → Regeneration\n\n6. Success/Failure → mnemosyne\n   → Store patterns for learning\n</code></pre>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#performance-architecture","level":2,"title":"Performance Architecture","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#optimization-strategies","level":3,"title":"Optimization Strategies","text":"<p>1. Multi-Level Caching: <pre><code>L1: Grammar Cache (1000 entries)\n    - Content-based hashing\n    - Lazy compilation on miss\n    - &lt;1μs retrieval\n\nL2: Mask Cache (100k entries, LRU)\n    - (Grammar hash, State hash) → Mask\n    - &lt;1μs retrieval on hit\n    - 89% hit rate achieved\n\nL3: Type Environment Cache\n    - Per-file type contexts\n    - Incremental updates\n    - &lt;100μs retrieval\n</code></pre></p> <p>2. Lazy Evaluation: - Grammar construction: Build states on demand - Type search: Depth-limited with early termination - Validation: Parallel execution of independent checks</p> <p>3. Parallelization: <pre><code>Parallel Indexing: Index multiple files concurrently\nParallel Validation: Run syntax, types, tests concurrently\nParallel Generation: Speculative generation with multiple constraints\n</code></pre></p> <p>4. Profiling and Metrics: <pre><code># Automatic performance tracking\nadapter.enable_profiling = True\n\n# After generation\nstats = adapter.get_performance_summary()\nassert stats['p99_us'] &lt; 100  # Enforce targets\n</code></pre></p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#extensibility-points","level":2,"title":"Extensibility Points","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#adding-a-new-language","level":3,"title":"Adding a New Language","text":"<ol> <li> <p>Create Indexer (<code>src/maze/indexer/languages/newlang.py</code>):    <pre><code>class NewLangIndexer(BaseIndexer):\n    def __init__(self):\n        self.language = \"newlang\"\n        self.file_extensions = {\".ext\"}\n\n    def extract_symbols(self, content: str) -&gt; List[Symbol]:\n        # Language-specific extraction\n        ...\n</code></pre></p> </li> <li> <p>Create Grammar Template (<code>src/maze/synthesis/grammars/newlang.lark</code>):    <pre><code>?start: module\nmodule: statement+\n# ... language grammar\n</code></pre></p> </li> <li> <p>Add Type System (<code>src/maze/type_system/languages/newlang.py</code>):    <pre><code>class NewLangTypeSystem(TypeSystemBase):\n    def infer_type(self, expr: str) -&gt; Type:\n        # Language-specific type inference\n        ...\n</code></pre></p> </li> <li> <p>Add Tests:</p> </li> <li>Unit tests in <code>tests/unit/test_indexer/test_newlang.py</code></li> <li>Performance benchmarks</li> <li>Integration tests</li> </ol>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#adding-a-provider-adapter","level":3,"title":"Adding a Provider Adapter","text":"<ol> <li> <p>Create Adapter (<code>src/maze/orchestrator/providers/newprovider.py</code>):    <pre><code>class NewProviderAdapter(ProviderAdapter):\n    async def generate_with_grammar(self, prompt, grammar):\n        # Provider-specific implementation\n        ...\n</code></pre></p> </li> <li> <p>Register in Factory:    <pre><code>def create_adapter(provider: str):\n    adapters = {\n        \"newprovider\": NewProviderAdapter,\n        ...\n    }\n</code></pre></p> </li> <li> <p>Add Integration Tests:    <pre><code># tests/integration/test_providers/test_newprovider.py\n@pytest.mark.integration\ndef test_newprovider_generation():\n    ...\n</code></pre></p> </li> </ol>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#security-architecture","level":2,"title":"Security Architecture","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#sandboxing-rune-integration","level":3,"title":"Sandboxing (RUNE Integration)","text":"<p>Threat Model: - Untrusted generated code - Potential for malicious patterns - Resource exhaustion attacks</p> <p>Mitigations: <pre><code># All test execution in isolated sandbox\nsandbox = await rune.create_sandbox(\n    timeout=30,              # Kill after 30s\n    memory_limit_mb=512,     # Max 512MB RAM\n    network=False,           # No network access\n    filesystem=\"isolated\"    # Temporary FS\n)\n</code></pre></p> <p>Safety Guarantees: - Process isolation - Resource limits (CPU, memory, time) - Filesystem isolation - Network isolation - No access to host system</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#monitoring-and-observability","level":2,"title":"Monitoring and Observability","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#metrics-collection","level":3,"title":"Metrics Collection","text":"<pre><code>from maze.utils.metrics import metrics\n\n# Timing metrics\nmetrics.record_duration(\"mask_computation\", duration_us)\nmetrics.record_duration(\"type_search\", duration_ms)\nmetrics.record_duration(\"validation\", duration_s)\n\n# Count metrics\nmetrics.increment(\"generations_started\")\nmetrics.increment(\"generations_succeeded\")\nmetrics.increment(\"repair_attempts\")\n\n# Distribution metrics\nmetrics.record_distribution(\"tokens_per_generation\", count)\nmetrics.record_distribution(\"cache_hit_rate\", percentage)\n</code></pre>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#performance-tracking","level":3,"title":"Performance Tracking","text":"<p>All performance-critical operations are automatically profiled: - Token mask computation (target: &lt;100μs) - Grammar compilation (target: &lt;50ms) - Type search (target: &lt;1ms) - Cache hit rates (target: &gt;70%)</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#testing-architecture","level":2,"title":"Testing Architecture","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#test-pyramid","level":3,"title":"Test Pyramid","text":"<pre><code>          ┌─────────┐\n          │   E2E   │  &lt;- HumanEval, MBPP, Real tasks\n          │  Tests  │     (Slow, comprehensive)\n          └─────────┘\n        ┌─────────────┐\n        │ Integration │  &lt;- Multi-component, external systems\n        │    Tests    │     (Medium speed)\n        └─────────────┘\n    ┌───────────────────┐\n    │   Unit Tests      │  &lt;- Individual components\n    │  + Performance    │     (Fast, targeted)\n    └───────────────────┘\n</code></pre> <p>Test Organization: - <code>tests/unit/</code> - Component tests (90%+ coverage target) - <code>tests/integration/</code> - System integration tests - <code>tests/e2e/</code> - End-to-end workflows - <code>benchmarks/</code> - Performance validation</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#future-architecture","level":2,"title":"Future Architecture","text":"","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#planned-enhancements-phase-4-6","level":3,"title":"Planned Enhancements (Phase 4-6)","text":"<p>Phase 4: Validation &amp; Repair - Multi-level validator with parallel execution - Repair loop with constraint refinement - Full pedantic_raven integration</p> <p>Phase 5: Adaptive Learning - Pattern mining from successful generations - Constraint learning with reinforcement - Project-specific adaptation</p> <p>Phase 6: Production Optimization - Speculative decoding - Model distillation for edge deployment - IDE integration (LSP server) - Real-time feedback</p>","path":["Maze Architecture"],"tags":[]},{"location":"architecture/#references","level":2,"title":"References","text":"<ul> <li>Work Plan Protocol</li> <li>Constraint Development</li> <li>Performance Targets</li> <li>Integration Guidelines</li> </ul>","path":["Maze Architecture"],"tags":[]},{"location":"whitepaper/","level":1,"title":"MAZE Whitepaper","text":"<p>Adaptive Constrained Code Generation</p> <p>Version: v0.1.0-whitepaper Date: November 2025 Repository: github.com/rand/maze</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#abstract","level":2,"title":"Abstract","text":"<p>Large Language Models (LLMs) have demonstrated remarkable capabilities in code generation, yet they suffer from high error rates when generating complex, type-correct code. Unconstrained generation often produces syntactically valid but semantically incorrect or type-unsafe code, requiring expensive post-hoc validation and multiple repair iterations.</p> <p>MAZE introduces a paradigm shift: compile constraints before decoding, rather than hoping for correctness after generation. Through a novel 4-tier constraint hierarchy—syntactic (CFG grammars), type (inhabitation search), semantic (test-driven), and contextual (learned patterns)—MAZE guides LLM generation toward valid, type-correct, and project-conformant code from the start.</p> <p>Built on research from PLDI 2025 (Type-Constrained Code Generation) and OOPSLA 2024 (Typed Holes), MAZE integrates with multiple LLM providers (OpenAI, vLLM, SGLang, llama.cpp) through llguidance for constraint enforcement, mnemosyne for persistent learning, and RUNE for sandboxed validation.</p> <p>Current status: Core constraint system complete (Phases 1-3), validation pipeline in active development (Phase 4: 6/10 tasks complete), with adaptive learning and production hardening planned (Phases 5-6).</p> <p>Significance: MAZE demonstrates that formal constraint enforcement can be integrated with modern LLMs without sacrificing generation speed, providing a foundation for the next generation of AI-assisted development tools.</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#table-of-contents","level":2,"title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Problem Statement</li> <li>Architecture Overview</li> <li>4-Tier Constraint System</li> <li>Type-Directed Synthesis</li> <li>Integration Ecosystem</li> <li>Implementation Status and Roadmap</li> <li>Research Foundation</li> <li>Architecture Validation</li> <li>Getting Started</li> <li>Conclusion</li> <li>Resources</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#1-introduction","level":2,"title":"1. Introduction","text":"","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#the-code-generation-challenge","level":3,"title":"The Code Generation Challenge","text":"<p>Large Language Models have revolutionized software development assistance, enabling developers to generate substantial code from natural language descriptions. However, this capability comes with a fundamental limitation: without explicit constraints, LLMs generate code based solely on statistical patterns learned from training data. This approach produces code that is often:</p> <ul> <li>Syntactically plausible but incorrect</li> <li>Type-unsafe, causing compilation failures</li> <li>Semantically wrong, failing to implement the specified behavior</li> <li>Inconsistent with project conventions and patterns</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#mazes-paradigm-shift","level":3,"title":"MAZE's Paradigm Shift","text":"<p>MAZE reverses this paradigm. Instead of hoping the LLM generates correct code, MAZE compiles constraints before token generation, guiding the model toward valid outputs from the start.</p> <p>Traditional Approach: <pre><code>Generate (unconstrained) → Validate → Find errors → Fix → Repeat\n</code></pre></p> <p>MAZE Approach: <pre><code>Build constraints → Generate (constrained) → Minimal validation → Done\n</code></pre></p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#architecture-foundation","level":3,"title":"Architecture Foundation","text":"<p>MAZE is built on four key innovations:</p> <ol> <li>4-Tier Constraint Hierarchy: Progressive constraint tightening from syntax through types, semantics, and context</li> <li>Type-Directed Synthesis: Bidirectional type inference and inhabitation search for type-correct code paths</li> <li>Multi-System Integration: Seamless integration with llguidance, mnemosyne, RUNE, and pedantic_raven</li> <li>Provider Agnosticism: Support for OpenAI, vLLM, SGLang, and llama.cpp through unified adapters</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#2-problem-statement","level":2,"title":"2. Problem Statement","text":"","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#unconstrained-llm-generation-failures","level":3,"title":"Unconstrained LLM Generation Failures","text":"<p>Consider a request to generate a TypeScript function:</p> <pre><code>\"Create an async function that fetches a user by ID and returns their email\"\n</code></pre> <p>An unconstrained LLM might generate:</p> <pre><code>async function getUserEmail(id) {\n  const user = await fetchUser(id);\n  return user.email;\n}\n</code></pre> <p>This code has multiple issues:</p> <ol> <li>Missing type annotations: Parameters and return type unspecified</li> <li>Type safety violation: <code>user</code> might be <code>null</code> or <code>undefined</code></li> <li>Incomplete error handling: Network failures unhandled</li> <li>Contextual mismatch: May not match project's error handling patterns</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#the-cost-of-post-hoc-validation","level":3,"title":"The Cost of Post-Hoc Validation","text":"<p>Post-generation validation creates a costly feedback loop:</p> <ul> <li>Iteration 1: Generate code → Compile → Find type errors → Prompt for fixes</li> <li>Iteration 2: Generate fixes → Compile → Find new errors → Prompt again</li> <li>Iteration 3: Generate fixes → Compile → Test → Find semantic errors → Prompt again</li> </ul> <p>In practice, research shows unconstrained generation often requires 3-5 iterations before producing working code. Each iteration consumes LLM API calls, increases latency, risks context window overflow, and frustrates developers.</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#type-errors-in-generated-code","level":3,"title":"Type Errors in Generated Code","text":"<p>Type errors are particularly problematic because they cascade. A single type mismatch can cause compilation failures blocking all downstream work, silent bugs when type coercion hides errors, integration failures when code doesn't match API contracts, and maintenance burden as type-unsafe code spreads through the codebase.</p> <p>Research by Mündler et al. (PLDI 2025) found that unconstrained LLMs produce type errors in over 50% of generated functions for typed languages like TypeScript and Rust.</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#3-architecture-overview","level":2,"title":"3. Architecture Overview","text":"<p>MAZE's architecture consists of five integrated stages that transform a code generation request into validated, type-correct code:</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#stage-1-context-indexer","level":3,"title":"Stage 1: Context Indexer","text":"<p>Purpose: Extract structured information from source code to inform constraint synthesis</p> <p>Current Implementation:</p> <ul> <li>TypeScript Indexer ✅ Complete</li> <li>Extracts functions, classes, interfaces, type aliases</li> <li>Parses type annotations and generic parameters</li> <li>Detects project style (indentation, quotes, semicolons)</li> <li>Identifies test patterns (Jest, Mocha, Vitest)</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#stage-2-constraint-synthesis","level":3,"title":"Stage 2: Constraint Synthesis","text":"<p>Purpose: Build hierarchical constraints from indexed context and generation request</p> <p>Components:</p> <ol> <li>GrammarBuilder ✅: Generates CFG grammars in Lark format</li> <li>TypeToGrammarConverter ✅: Converts type constraints into grammar constraints</li> <li>SchemaBuilder ✅: Generates JSON Schema for structured output (OpenAI compatibility)</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#stage-3-decode-orchestrator","level":3,"title":"Stage 3: Decode Orchestrator","text":"<p>Purpose: Generate code under constraints using provider-specific adapters</p> <p>Integration: llguidance for fast constraint enforcement</p> <p>Provider Adapters ✅:</p> <ul> <li>OpenAI: JSON Schema mode via structured outputs</li> <li>vLLM: Full CFG grammar support</li> <li>SGLang: Native llguidance integration</li> <li>llama.cpp: Grammar-based generation</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#stage-4-post-validation","level":3,"title":"Stage 4: Post-Validation","text":"<p>Purpose: Validate generated code across multiple dimensions in parallel</p> <p>Validators (parallel execution):</p> <ol> <li>SyntaxValidator ✅ Complete: Language-specific syntax checking</li> <li>TypeValidator ✅ Complete: Type checking via language-specific tools</li> <li>TestValidator ✅ Complete: Executes tests in RUNE sandbox</li> <li>LintValidator ✅ Complete: Style checking (ESLint, Ruff, Clippy)</li> <li>ValidationPipeline ✅ Complete: Orchestrates parallel validation</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#stage-5-repair-loop","level":3,"title":"Stage 5: Repair Loop","text":"<p>Status: 📋 Planned (Phase 4)</p> <p>Planned Components:</p> <ul> <li>RepairOrchestrator: Manages repair iterations</li> <li>DiagnosticAnalyzer: Interprets validation failures</li> <li>ConstraintRefinement: Tightens constraints based on diagnostics</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#integration-flow","level":3,"title":"Integration Flow","text":"<p>MAZE integrates with four external systems:</p> <ol> <li>llguidance (Microsoft Research): Constraint enforcement during decoding</li> <li>mnemosyne: Persistent memory for pattern learning across sessions</li> <li>RUNE: Sandboxed execution for safe test validation</li> <li>pedantic_raven: Deep semantic validation (planned integration)</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#4-4-tier-constraint-system","level":2,"title":"4. 4-Tier Constraint System","text":"<p>MAZE's core innovation is a hierarchical constraint system that progressively narrows the space of valid programs:</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#tier-1-syntactic-constraints-cfg-grammars","level":3,"title":"Tier 1: Syntactic Constraints (CFG Grammars)","text":"<p>Purpose: Ensure generated code is syntactically valid</p> <p>Implementation: Context-Free Grammars (CFG) in Lark format</p> <p>Status: ✅ Complete for TypeScript, partial for Python/Rust</p> <p>Benefits:</p> <ul> <li>Guaranteed syntactic validity: Generated code always parses</li> <li>Language-aware generation: LLM respects language syntax rules</li> <li>Composability: Grammars can be combined and extended</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#tier-2-type-constraints-inhabitation-search","level":3,"title":"Tier 2: Type Constraints (Inhabitation Search)","text":"<p>Purpose: Ensure generated code is type-correct</p> <p>Implementation: Type inhabitation solver + type-to-grammar conversion</p> <p>Status: ✅ Complete</p> <p>Research Foundation: Mündler et al., \"Type-Constrained Code Generation\" (PLDI 2025, arXiv:2504.09246)</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#key-concept-type-inhabitation","level":4,"title":"Key Concept: Type Inhabitation","text":"<p>Given a source type <code>S</code> and target type <code>T</code>, find valid transformation paths.</p> <p>Example: Finding <code>User → string</code> paths</p> <p>Given:</p> <pre><code>interface User {\n  id: string;\n  name: string;\n  email: string;\n  age: number;\n  toString(): string;\n}\n</code></pre> <p>Valid paths:</p> <ol> <li><code>user.id</code> → <code>string</code> ✅ (property access)</li> <li><code>user.name</code> → <code>string</code> ✅ (property access)</li> <li><code>user.email</code> → <code>string</code> ✅ (property access)</li> <li><code>user.toString()</code> → <code>string</code> ✅ (method call)</li> </ol> <p>Invalid paths:</p> <ul> <li><code>user.age</code> → <code>string</code> ❌ (type mismatch: number → string)</li> <li><code>user</code> → <code>string</code> ❌ (no direct conversion)</li> </ul> <p>Benefits:</p> <ul> <li>Type safety: Generated code is type-correct by construction</li> <li>Error reduction: Eliminates type errors that plague unconstrained generation</li> <li>Contextual awareness: Leverages project's type hierarchy</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#tier-3-semantic-constraints-test-driven","level":3,"title":"Tier 3: Semantic Constraints (Test-Driven)","text":"<p>Purpose: Ensure generated code implements specified behavior</p> <p>Implementation: Test cases + property specifications</p> <p>Status: ✅ Validators complete, orchestration planned</p> <p>Semantic constraints are specified through:</p> <ol> <li>Concrete test cases: Input/output examples</li> <li>Property-based constraints: Invariants that must hold</li> </ol> <p>Integration with RUNE: All test execution happens in RUNE sandboxes to ensure network isolation, filesystem isolation, resource limits, and deterministic execution.</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#tier-4-contextual-constraints-learned","level":3,"title":"Tier 4: Contextual Constraints (Learned)","text":"<p>Purpose: Ensure generated code matches project conventions and patterns</p> <p>Implementation: Pattern mining + mnemosyne integration</p> <p>Status: 📋 Planned (Phase 5)</p> <p>Projects have implicit conventions that go beyond syntax, types, and semantics:</p> <ul> <li>Naming conventions (camelCase, PascalCase, snake_case)</li> <li>Error handling patterns (try/catch, Result types, null checks)</li> <li>Async patterns (async/await vs. .then(), Promise usage)</li> <li>Import organization (alphabetical, grouped by source)</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#constraint-composition","level":3,"title":"Constraint Composition","text":"<p>The four tiers compose hierarchically:</p> <pre><code>Syntactic constraints (broadest)\n  ↓ Narrows to syntactically valid programs\nType constraints\n  ↓ Narrows to type-correct programs\nSemantic constraints\n  ↓ Narrows to behaviorally correct programs\nContextual constraints\n  ↓ Narrows to project-conformant programs\n</code></pre>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#5-type-directed-synthesis","level":2,"title":"5. Type-Directed Synthesis","text":"<p>Type-directed synthesis is MAZE's most sophisticated capability, enabling generation of type-correct code through formal type theory.</p> <p>Research Foundation: Mündler et al. (PLDI 2025) and Blinn et al. (OOPSLA 2024)</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#bidirectional-type-inference","level":3,"title":"Bidirectional Type Inference","text":"<p>MAZE implements bidirectional type inference to propagate type information in both directions:</p> <ul> <li>Synthesis mode (bottom-up): Infer type of expression from sub-expressions</li> <li>Checking mode (top-down): Check if expression matches expected type</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#type-inhabitation-solver","level":3,"title":"Type Inhabitation Solver","text":"<p>Purpose: Find expressions that inhabit (produce) a given type</p> <p>Optimization Techniques:</p> <ol> <li>Memoization: Cache results to avoid redundant searches</li> <li>Depth limiting: Prevent infinite recursion (default: max_depth=5)</li> <li>Ranking: Prioritize simpler expressions (fewer steps)</li> <li>Pruning: Eliminate type-incompatible paths early</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#typed-hole-filling","level":3,"title":"Typed Hole Filling","text":"<p>Research Foundation: Blinn et al., \"Statically Contextualizing LLMs with Typed Holes\" (OOPSLA 2024, arXiv:2409.00921)</p> <p>Concept: Partial code with \"holes\" to be filled</p> <p>Example:</p> <pre><code>async function getUserEmail(id: string): Promise&lt;string&gt; {\n  const user = await fetchUser(id);\n\n  if (user === null) {\n    /*__HOLE__*/  // What should we return here?\n  }\n\n  return /*__HOLE__*/;  // What expression returns string from User?\n}\n</code></pre>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#6-integration-ecosystem","level":2,"title":"6. Integration Ecosystem","text":"","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#llguidance-constraint-enforcement","level":3,"title":"llguidance: Constraint Enforcement","text":"<p>Source: Microsoft Research, guidance-ai/llguidance</p> <p>Purpose: Efficient constraint enforcement during LLM decoding</p> <p>Performance (upstream benchmarks):</p> <ul> <li>Mask computation: ~50μs per token (p99, 128k tokenizer)</li> <li>Grammar compilation: &lt;50ms for typical programming language grammars</li> <li>Memory overhead: ~10MB per grammar automaton</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#mnemosyne-persistent-memory","level":3,"title":"mnemosyne: Persistent Memory","text":"<p>Source: rand/mnemosyne, Documentation</p> <p>Purpose: Semantic memory and learning across sessions</p> <p>Status: ✅ Basic integration complete, full adaptive learning planned (Phase 5)</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#rune-sandboxed-execution","level":3,"title":"RUNE: Sandboxed Execution","text":"<p>Source: rand/RUNE, Documentation</p> <p>Purpose: Safe, isolated execution for test validation</p> <p>Safety Guarantees:</p> <ul> <li>Network isolation: No external network access</li> <li>Filesystem isolation: Temporary directory only</li> <li>Resource limits: CPU, memory, and time quotas enforced</li> <li>Deterministic execution: Same input → same output</li> </ul> <p>Status: ✅ Complete integration via RuneExecutor</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#pedantic_raven-quality-enforcement","level":3,"title":"pedantic_raven: Quality Enforcement","text":"<p>Source: rand/pedantic_raven</p> <p>Status: 📋 Placeholder exists, full integration planned (Phase ⅘)</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#7-implementation-status-and-roadmap","level":2,"title":"7. Implementation Status and Roadmap","text":"","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#current-status-active-development","level":3,"title":"Current Status: Active Development","text":"<p>MAZE has completed its core architectural foundation (Phases 1-3) and is actively building the validation and repair pipeline (Phase 4).</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#phase-1-3-core-system-complete","level":3,"title":"Phase 1-3: Core System ✅ COMPLETE","text":"<p>10,847 lines of code across 43 source files</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#phase-1-foundation","level":4,"title":"Phase 1: Foundation","text":"<ul> <li>✅ Core type system</li> <li>✅ Constraint abstractions</li> <li>✅ llguidance integration</li> <li>✅ TypeScript indexer</li> <li>✅ Test infrastructure (29 test files)</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#phase-2-syntactic-synthesis","level":4,"title":"Phase 2: Syntactic Synthesis","text":"<ul> <li>✅ Grammar builder</li> <li>✅ JSON Schema builder</li> <li>✅ Provider adapters</li> <li>✅ Language grammars: TypeScript (complete), Python/Rust (partial)</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#phase-3-type-system","level":4,"title":"Phase 3: Type System","text":"<p>2,124 lines dedicated to type system</p> <ul> <li>✅ Type inference engine</li> <li>✅ Type inhabitation solver</li> <li>✅ Typed holes</li> <li>✅ Type-to-grammar converter</li> <li>✅ TypeScript type system</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#phase-4-validation-repair-in-progress-610-complete","level":3,"title":"Phase 4: Validation &amp; Repair 🚧 IN PROGRESS (6/10 complete)","text":"<p>Recent Progress (as of November 8, 2025):</p> <p>✅ Complete Components:</p> <ol> <li>SyntaxValidator - Commit 013846c</li> <li>TypeValidator - Commit a1b463c</li> <li>TestValidator - Commit 3f8f006</li> <li>LintValidator - Commit 7a91e04</li> <li>RuneExecutor - Commit 0e358b4</li> <li>ValidationPipeline - Commit b4b31c6</li> </ol> <p>📋 Remaining Tasks:</p> <ul> <li>RepairOrchestrator: Manages repair iteration logic</li> <li>DiagnosticAnalyzer: Interprets validation failures</li> <li>ConstraintRefinement: Tightens constraints based on diagnostics</li> <li>Full pedantic_raven integration: Deep semantic validation</li> </ul> <p>Expected Completion: December 2025</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#phase-5-adaptive-learning-planned","level":3,"title":"Phase 5: Adaptive Learning 📋 PLANNED","text":"<p>Timeline: Q1 2026</p> <ul> <li>Pattern mining from existing codebases</li> <li>Constraint learning from generation outcomes</li> <li>Full mnemosyne integration for persistent learning</li> <li>Project-specific pattern adaptation</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#phase-6-production-planned","level":3,"title":"Phase 6: Production 📋 PLANNED","text":"<p>Timeline: Q2 2026</p> <ul> <li>Performance optimization (speculative decoding, parallelization)</li> <li>Multi-language indexers (Python, Rust, Go, Zig completion)</li> <li>IDE integrations (VSCode, IntelliJ plugins)</li> <li>Comprehensive benchmarking: HumanEval, MBPP, SWE-bench-lite</li> <li>Production deployment guides</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#8-research-foundation","level":2,"title":"8. Research Foundation","text":"<p>MAZE builds on established research in constrained generation, program synthesis, and type theory:</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#type-constrained-code-generation-pldi-2025","level":3,"title":"Type-Constrained Code Generation (PLDI 2025)","text":"<p>Paper: Mündler et al., \"Type-Constrained Code Generation with Language Models\"</p> <p>Venue: PLDI 2025</p> <p>arXiv: 2504.09246</p> <p>Key Contributions:</p> <ol> <li>Type constraints as prefix automata</li> <li>Bidirectional type inference for LLM guidance</li> <li>Reported &gt;50% reduction in compilation errors</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#statically-contextualizing-llms-with-typed-holes-oopsla-2024","level":3,"title":"Statically Contextualizing LLMs with Typed Holes (OOPSLA 2024)","text":"<p>Paper: Blinn et al., \"Statically Contextualizing Large Language Models with Typed Holes\"</p> <p>Venue: OOPSLA 2024</p> <p>arXiv: 2409.00921</p> <p>Key Contributions:</p> <ol> <li>Typed holes for partial code completion</li> <li>Static context extraction for LLM guidance</li> <li>Evaluation on real-world TypeScript codebases</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#llguidance-constraint-enforcement-for-llms","level":3,"title":"LLGuidance: Constraint Enforcement for LLMs","text":"<p>Source: Microsoft Research, guidance-ai/llguidance</p> <p>Key Contributions:</p> <ol> <li>Efficient CFG grammar enforcement during decoding</li> <li>Sub-100μs token mask computation</li> <li>Provider-agnostic integration</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#9-architecture-validation","level":2,"title":"9. Architecture Validation","text":"<p>All claims in this whitepaper are validated against the codebase at tag <code>v0.1.0-whitepaper</code>.</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#code-statistics","level":3,"title":"Code Statistics","text":"Metric Value Total source files 43 Total source lines 10,847 Test files 29 Type system lines 2,124","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#component-verification","level":3,"title":"Component Verification","text":"<p>All components link to tagged source code at <code>v0.1.0-whitepaper</code> for verification:</p> <ul> <li>Core Type System ✅: types.py, constraints.py</li> <li>Type System ✅ (2,124 lines): Multiple modules in type_system/</li> <li>Synthesis ✅: synthesis/</li> <li>Validation ✅: validation/</li> <li>Integrations ✅: llguidance, mnemosyne, RUNE in integrations/</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#10-getting-started","level":2,"title":"10. Getting Started","text":"","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#installation","level":3,"title":"Installation","text":"<p>MAZE requires Python 3.10+ and uses <code>uv</code> for dependency management:</p> <pre><code># Clone repository\ngit clone https://github.com/rand/maze\ncd maze\n\n# Install dependencies\nuv pip install -e \".[dev]\"\n\n# Verify installation\nuv run python -c \"import maze; print('MAZE installed successfully')\"\n</code></pre>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#basic-usage-conceptual","level":3,"title":"Basic Usage (Conceptual)","text":"<pre><code>from maze.core.constraints import ConstraintSet, SyntacticConstraint\nfrom maze.type_system.context import TypeContext\nfrom maze.orchestrator import generate\n\n# 1. Define constraints\nconstraints = ConstraintSet()\nconstraints.add(SyntacticConstraint.from_language(\"typescript\"))\n\n# 2. Optionally add type context\ntype_context = TypeContext()\ntype_context.add_type(\"User\", {\n    \"id\": \"string\",\n    \"name\": \"string\",\n    \"email\": \"string\"\n})\n\n# 3. Generate code\ncode = generate(\n    prompt=\"Create an async function that fetches a user by ID and returns their email\",\n    constraints=constraints,\n    type_context=type_context\n)\n\nprint(code)\n</code></pre>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#11-conclusion","level":2,"title":"11. Conclusion","text":"","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#summary-of-contributions","level":3,"title":"Summary of Contributions","text":"<p>MAZE introduces a novel approach to code generation that shifts from post-hoc validation to pre-generation constraint enforcement:</p> <ol> <li>4-Tier Constraint Hierarchy: Progressive constraint tightening from syntax through types, semantics, and context</li> <li>Type-Directed Synthesis: Bidirectional type inference and inhabitation search for type-correct code paths</li> <li>Multi-System Integration: Seamless integration with llguidance, mnemosyne, RUNE, and pedantic_raven</li> <li>Research-Backed Design: Built on PLDI 2025 and OOPSLA 2024 research</li> <li>Provider-Agnostic Architecture: Support for OpenAI, vLLM, SGLang, and llama.cpp</li> </ol>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#current-state-solid-foundation","level":3,"title":"Current State: Solid Foundation","text":"<p>With 10,847 lines of code across 43 source files, MAZE has completed its core architectural foundation:</p> <ul> <li>Phase 1-3: Type system, constraint synthesis, and core integrations complete</li> <li>Phase 4: Validation pipeline 60% complete (6/10 tasks)</li> <li>Phase 5-6: Adaptive learning and production hardening planned</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#future-work","level":3,"title":"Future Work","text":"<p>Short Term (Phase 4, Q4 2025):</p> <ul> <li>Complete repair orchestrator</li> <li>Diagnostic analyzer for intelligent constraint refinement</li> <li>Full pedantic_raven integration</li> </ul> <p>Medium Term (Phase 5, Q1 2026):</p> <ul> <li>Pattern mining from codebases</li> <li>Adaptive constraint learning</li> <li>Project-specific pattern adaptation</li> </ul> <p>Long Term (Phase 6, Q2 2026):</p> <ul> <li>Multi-language indexer completion (Python, Rust, Go, Zig)</li> <li>Comprehensive benchmark evaluation (HumanEval, MBPP, SWE-bench)</li> <li>IDE integrations (VSCode, IntelliJ)</li> <li>Production deployment optimization</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#12-resources","level":2,"title":"12. Resources","text":"","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#project-links","level":3,"title":"Project Links","text":"<ul> <li>GitHub Repository: github.com/rand/maze</li> <li>Documentation: CLAUDE.md, AGENT_GUIDE.md</li> <li>Whitepaper: maze whitepaper</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#research-papers","level":3,"title":"Research Papers","text":"<ul> <li>Type-Constrained Code Generation: arXiv:2504.09246 (PLDI 2025)</li> <li>Typed Holes: arXiv:2409.00921 (OOPSLA 2024)</li> </ul>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/#related-projects","level":3,"title":"Related Projects","text":"<ul> <li>llguidance: github.com/guidance-ai/llguidance (Microsoft Research)</li> <li>mnemosyne: rand.github.io/mnemosyne (Memory &amp; Learning)</li> <li>RUNE: rand.github.io/RUNE (Sandboxed Execution)</li> </ul> <p>Version: v0.1.0-whitepaper Last Updated: November 2025 License: [To be determined]</p>","path":["MAZE Technical Whitepaper"],"tags":[]},{"location":"whitepaper/validation-manifest/","level":1,"title":"MAZE Whitepaper Validation Manifest","text":"<p>Version: v0.1.0-whitepaper Date: November 8, 2025 Purpose: Validate all claims and code references in MAZE whitepaper</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#source-code-statistics","level":2,"title":"Source Code Statistics","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#file-counts","level":3,"title":"File Counts","text":"<ul> <li>Total Python source files: 43</li> <li>Total source lines: 10,847</li> <li>Test files: 29</li> <li>Benchmark scripts: 0 (directory exists but empty)</li> </ul>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#component-line-counts","level":3,"title":"Component Line Counts","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#type-system-2124-lines-total","level":4,"title":"Type System (2,124 lines total)","text":"<pre><code>src/maze/type_system/\n├── __init__.py\n├── inference.py\n├── inhabitation.py\n├── holes.py\n├── grammar_converter.py\n└── languages/\n    └── typescript.py\n</code></pre>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#validation-pipeline","level":4,"title":"Validation Pipeline","text":"<pre><code>src/maze/validation/\n├── syntax.py          # SyntaxValidator ✅\n├── types.py           # TypeValidator ✅\n├── tests.py           # TestValidator ✅\n├── lint.py            # LintValidator ✅\n└── pipeline.py        # ValidationPipeline ✅\n</code></pre>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#integration-modules","level":4,"title":"Integration Modules","text":"<pre><code>src/maze/integrations/\n├── llguidance/        # llguidance integration ✅\n├── mnemosyne/         # mnemosyne integration ✅\n├── rune/              # RUNE integration ✅\n└── pedantic_raven/    # pedantic_raven integration (placeholder)\n</code></pre>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#synthesis-modules","level":4,"title":"Synthesis Modules","text":"<pre><code>src/maze/synthesis/\n├── grammar_builder.py    # CFG grammar synthesis ✅\n└── schema_builder.py     # JSON Schema synthesis ✅\n</code></pre>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#indexer","level":4,"title":"Indexer","text":"<pre><code>src/maze/indexer/\n└── languages/\n    └── typescript.py     # TypeScript indexer ✅\n</code></pre>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#implementation-status-by-phase","level":2,"title":"Implementation Status by Phase","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-1-foundation-complete","level":3,"title":"Phase 1: Foundation ✅ COMPLETE","text":"<p>Status: Released v0.1.0 (November 8, 2025)</p> <p>Evidence: - Core type system: <code>src/maze/core/types.py</code> - Constraint abstractions: <code>src/maze/core/constraints.py</code> - llguidance integration: <code>src/maze/integrations/llguidance/</code> - TypeScript indexer: <code>src/maze/indexer/languages/typescript.py</code> - Test infrastructure: 29 test files across <code>tests/unit/</code>, <code>tests/integration/</code>, <code>tests/e2e/</code></p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-2-syntactic-constraints-complete","level":3,"title":"Phase 2: Syntactic Constraints ✅ COMPLETE","text":"<p>Status: Complete</p> <p>Evidence: - Grammar builder: <code>src/maze/synthesis/grammar_builder.py</code> - JSON Schema builder: <code>src/maze/synthesis/schema_builder.py</code> - Provider adapters: <code>src/maze/orchestrator/providers/</code> - Language grammars: TypeScript ✅, Python (partial), Rust (partial)</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-3-type-system-complete","level":3,"title":"Phase 3: Type System ✅ COMPLETE","text":"<p>Status: Complete (commit a3fad53, November 8, 2025)</p> <p>Evidence: - Type inference engine: <code>src/maze/type_system/inference.py</code> - Type inhabitation solver: <code>src/maze/type_system/inhabitation.py</code> - Typed holes: <code>src/maze/type_system/holes.py</code> - Type-to-grammar converter: <code>src/maze/type_system/grammar_converter.py</code> - TypeScript type system: <code>src/maze/type_system/languages/typescript.py</code></p> <p>Git commits: - e598cb0: Type inference foundation - 161b821: Phase 3 integration complete - a3fad53: Beads state sync after Phase 3</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-4-validation-repair-in-progress","level":3,"title":"Phase 4: Validation &amp; Repair 🚧 IN PROGRESS","text":"<p>Status: 6/10 tasks complete (as of commit b4b31c6)</p> <p>Complete: - ✅ SyntaxValidator (commit 013846c) - ✅ TypeValidator (commit a1b463c) - ✅ TestValidator (commit 3f8f006) - ✅ LintValidator (commit 7a91e04) - ✅ RuneExecutor (commit 0e358b4) - ✅ ValidationPipeline (commit b4b31c6)</p> <p>Planned: - 📋 RepairOrchestrator - 📋 ConstraintRefinement - 📋 DiagnosticAnalyzer - 📋 Full pedantic_raven integration</p> <p>Latest commit: b4b31c6 - \"feat: Implement ValidationPipeline for multi-level validation orchestration\"</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-5-adaptive-learning-planned","level":3,"title":"Phase 5: Adaptive Learning 📋 PLANNED","text":"<p>Status: Not started</p> <p>Planned Components: - Pattern mining from codebases - Constraint learning from successes/failures - Full mnemosyne integration for pattern storage - Project-specific adaptation</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-6-production-planned","level":3,"title":"Phase 6: Production 📋 PLANNED","text":"<p>Status: Not started</p> <p>Planned Components: - Performance optimization (speculative decoding, parallelization) - Multi-provider production readiness - IDE integrations (VSCode, IntelliJ) - Comprehensive benchmarking (HumanEval, MBPP, SWE-bench)</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#research-paper-implementations","level":2,"title":"Research Paper Implementations","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#1-type-constrained-code-generation","level":3,"title":"1. Type-Constrained Code Generation","text":"<p>Paper: Mündler et al., \"Type-Constrained Code Generation with Language Models\" (PLDI 2025, arXiv:2504.09246)</p> <p>Implementation: - Type inhabitation solver: <code>src/maze/type_system/inhabitation.py</code> - Type-to-grammar conversion: <code>src/maze/type_system/grammar_converter.py</code> - Prefix automata construction integrated with llguidance</p> <p>Claim: Paper reports &gt;50% reduction in compilation errors MAZE approach: Architecture enables similar reduction (not yet benchmarked)</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#2-typed-holes","level":3,"title":"2. Typed Holes","text":"<p>Paper: Blinn et al., \"Statically Contextualizing LLMs with Typed Holes\" (OOPSLA 2024, arXiv:2409.00921)</p> <p>Implementation: - Typed hole filling: <code>src/maze/type_system/holes.py</code> - Type context extraction - Hole marker detection and completion</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#3-llguidance","level":3,"title":"3. LLGuidance","text":"<p>Source: Microsoft Research, guidance-ai/llguidance</p> <p>Implementation: - Integration layer: <code>src/maze/integrations/llguidance/</code> - CFG grammar enforcement - Provider adapters (OpenAI, vLLM, SGLang, llama.cpp)</p> <p>Performance: Upstream claims ~50μs per token (128k tokenizer)</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#performance-claims-status","level":2,"title":"Performance Claims Status","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#note-on-performance-claims","level":3,"title":"⚠️ Note on Performance Claims","text":"<p>The CHANGELOG.md documents the following performance achievements: - Token mask computation (p99): 50μs (target: &lt;100μs) - Grammar compilation: 42ms (target: &lt;50ms) - Type error reduction: 94% (target: &gt;75%) - Compilation success rate: 97% (target: &gt;95%) - Memory usage: 600MB (target: &lt;1GB) - Cache hit rate: 89% (target: &gt;70%)</p> <p>Validation Status: These claims are documented but benchmarks/ directory is currently empty. Performance claims should be considered preliminary pending benchmark suite implementation.</p> <p>Recommendation: Whitepaper focuses on architecture and design innovation rather than specific performance numbers until benchmarks are implemented and validated.</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#test-coverage","level":2,"title":"Test Coverage","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#test-organization","level":3,"title":"Test Organization","text":"<pre><code>tests/\n├── unit/              # Unit tests for individual components\n│   ├── test_core/\n│   ├── test_indexer/\n│   ├── test_synthesis/\n│   └── test_type_system/\n├── integration/       # Integration tests for multi-component workflows\n├── e2e/              # End-to-end scenario tests\n└── conftest.py       # Pytest configuration\n</code></pre> <p>Test count: 29 files</p> <p>Coverage targets (from CLAUDE.md): - Critical path: 90%+ - Business logic: 80%+ - UI layer: 60%+ - Overall: 70%+</p> <p>Current status: Test infrastructure complete, coverage reports not yet generated</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#git-commit-references","level":2,"title":"Git Commit References","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-completion-commits","level":3,"title":"Phase Completion Commits","text":"<ul> <li>Phase 1 completion: Initial v0.1.0 release</li> <li>Phase 2 completion: Grammar and schema synthesis</li> <li>Phase 3 completion: a3fad53 (November 8, 2025) - \"chore: Sync Beads state after Phase 3 completion\"</li> <li>Phase 3 integration: 161b821 - \"feat: Complete Phase 3 with integration and orchestration\"</li> </ul>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#phase-4-progress-commits","level":3,"title":"Phase 4 Progress Commits","text":"<ul> <li>013846c: SyntaxValidator</li> <li>a1b463c: TypeValidator</li> <li>3f8f006: TestValidator</li> <li>7a91e04: LintValidator</li> <li>0e358b4: RuneExecutor</li> <li>b4b31c6: ValidationPipeline</li> </ul>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#specification-documents","level":3,"title":"Specification Documents","text":"<ul> <li>specs/phase4-spec.md: Detailed Phase 4 specifications</li> <li>specs/phase4-full-spec.md: Comprehensive Phase 4 plan</li> </ul>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#whitepaper-code-link-pattern","level":2,"title":"Whitepaper Code Link Pattern","text":"<p>All code references in the whitepaper use the following format:</p> <pre><code>[Component Name](https://github.com/rand/maze/tree/v0.1.0-whitepaper/src/maze/path/to/file.py)\n</code></pre> <p>This ensures all links reference the exact codebase state validated in this manifest.</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#dependencies","level":2,"title":"Dependencies","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#core-dependencies","level":3,"title":"Core Dependencies","text":"<ul> <li>llguidance (Microsoft Research) - Constraint enforcement</li> <li>mnemosyne - Persistent memory and learning</li> <li>RUNE - Sandboxed execution</li> <li>pedantic_raven - Quality enforcement</li> </ul>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#language-support","level":3,"title":"Language Support","text":"<ul> <li>Complete: TypeScript (indexer + type system)</li> <li>Partial: Python (grammar templates)</li> <li>Partial: Rust (grammar templates)</li> <li>Planned: Go, Zig</li> </ul>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#validation-checklist","level":2,"title":"Validation Checklist","text":"<ul> <li> Source file count verified: 43 files</li> <li> Total line count verified: 10,847 lines</li> <li> Test file count verified: 29 files</li> <li> Type system line count verified: 2,124 lines</li> <li> Phase 1-3 completion verified via git commits</li> <li> Phase 4 progress verified: 6/10 tasks complete</li> <li> Research paper implementations mapped to source files</li> <li> Git commit hashes documented</li> <li> Performance benchmarks validated (PENDING - benchmarks/ empty)</li> <li> Test coverage report generated (PENDING)</li> <li> Multi-language support validated (TypeScript only complete)</li> </ul>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#change-log","level":2,"title":"Change Log","text":"","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/validation-manifest/#november-8-2025","level":3,"title":"November 8, 2025","text":"<ul> <li>Initial validation manifest created</li> <li>Verified against commit b4b31c6</li> <li>Documented Phase 1-3 complete, Phase 4 in progress (6/10)</li> <li>Noted performance claims as preliminary (no benchmark validation)</li> </ul> <p>Last Updated: November 8, 2025 Validated Against: Commit b4b31c6 Tag: v0.1.0-whitepaper (to be created)</p>","path":["MAZE Whitepaper Validation Manifest"],"tags":[]},{"location":"whitepaper/whitepaper/","level":1,"title":"MAZE: Adaptive Constrained Code Generation","text":"<p>A Research-Backed System for Type-Correct, Semantically Sound Code Generation</p> <p>Version: v0.1.0-whitepaper Date: November 2025 Author: Rand Arete</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#abstract","level":2,"title":"Abstract","text":"<p>Large Language Models (LLMs) have demonstrated remarkable capabilities in code generation, yet they suffer from high error rates when generating complex, type-correct code. Unconstrained generation often produces syntactically valid but semantically incorrect or type-unsafe code, requiring expensive post-hoc validation and multiple repair iterations.</p> <p>MAZE introduces a paradigm shift: compile constraints before decoding, rather than hoping for correctness after generation. Through a novel 4-tier constraint hierarchy—syntactic (CFG grammars), type (inhabitation search), semantic (test-driven), and contextual (learned patterns)—MAZE guides LLM generation toward valid, type-correct, and project-conform</p> <p>ant code from the start.</p> <p>Built on research from PLDI 2025 (Type-Constrained Code Generation) and OOPSLA 2024 (Typed Holes), MAZE integrates with multiple LLM providers (OpenAI, vLLM, SGLang, llama.cpp) through llguidance for constraint enforcement, mnemosyne for persistent learning, and RUNE for sandboxed validation.</p> <p>Current status: Core constraint system complete (Phases 1-3), validation pipeline in active development (Phase 4: 6/10 tasks complete), with adaptive learning and production hardening planned (Phases 5-6).</p> <p>Significance: MAZE demonstrates that formal constraint enforcement can be integrated with modern LLMs without sacrificing generation speed, providing a foundation for the next generation of AI-assisted development tools.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#1-introduction","level":2,"title":"1. Introduction","text":"","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#the-code-generation-challenge","level":3,"title":"The Code Generation Challenge","text":"<p>Large Language Models have revolutionized software development assistance, enabling developers to generate substantial code from natural language descriptions. However, this capability comes with a fundamental limitation: without explicit constraints, LLMs generate code based solely on statistical patterns learned from training data. This approach produces code that is often:</p> <ul> <li>Syntactically plausible but incorrect</li> <li>Type-unsafe, causing compilation failures</li> <li>Semantically wrong, failing to implement the specified behavior</li> <li>Inconsistent with project conventions and patterns</li> </ul> <p>The standard approach—generate freely, then validate and fix errors iteratively—wastes computational resources and developer time. Each iteration requires full re-generation, re-validation, and context management, creating an inefficient feedback loop.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#mazes-paradigm-shift","level":3,"title":"MAZE's Paradigm Shift","text":"<p>MAZE reverses this paradigm. Instead of hoping the LLM generates correct code, MAZE compiles constraints before token generation, guiding the model toward valid outputs from the start. This shift transforms the generation process:</p> <p>Traditional Approach: <pre><code>Generate (unconstrained) → Validate → Find errors → Fix → Repeat\n</code></pre></p> <p>MAZE Approach: <pre><code>Build constraints → Generate (constrained) → Minimal validation → Done\n</code></pre></p> <p>By enforcing constraints during decoding rather than after generation, MAZE reduces error rates, minimizes repair iterations, and produces higher-quality code with less computational overhead.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#architecture-foundation","level":3,"title":"Architecture Foundation","text":"<p>MAZE is built on four key innovations:</p> <ol> <li>4-Tier Constraint Hierarchy: Progressive constraint tightening from syntax through types, semantics, and context</li> <li>Type-Directed Synthesis: Bidirectional type inference and inhabitation search for type-correct code paths</li> <li>Multi-System Integration: Seamless integration with llguidance, mnemosyne, RUNE, and pedantic_raven</li> <li>Provider Agnosticism: Support for OpenAI, vLLM, SGLang, and llama.cpp through unified adapters</li> </ol>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#who-should-read-this","level":3,"title":"Who Should Read This","text":"<p>This whitepaper is for:</p> <ul> <li>Developers building AI-assisted development tools</li> <li>Researchers working on constrained generation and program synthesis</li> <li>AI Engineers integrating LLMs with formal methods</li> <li>Engineering Managers evaluating code generation technologies</li> </ul> <p>We assume familiarity with language models, type systems, and software engineering practices.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#document-structure","level":3,"title":"Document Structure","text":"<p>The remainder of this whitepaper proceeds as follows:</p> <ul> <li>Section 2: Problem statement and motivation</li> <li>Section 3: MAZE architecture overview</li> <li>Sections 4-6: Deep dive into constraint system, type synthesis, and integrations</li> <li>Sections 7-8: Implementation status and research foundation</li> <li>Sections 9-11: Validation, getting started, and conclusion</li> </ul>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#2-problem-statement","level":2,"title":"2. Problem Statement","text":"","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#unconstrained-llm-generation-failures","level":3,"title":"Unconstrained LLM Generation Failures","text":"<p>Consider a request to generate a TypeScript function:</p> <pre><code>\"Create an async function that fetches a user by ID and returns their email\"\n</code></pre> <p>An unconstrained LLM might generate:</p> <pre><code>async function getUserEmail(id) {\n  const user = await fetchUser(id);\n  return user.email;\n}\n</code></pre> <p>This code has multiple issues:</p> <ol> <li>Missing type annotations: Parameters and return type unspecified</li> <li>Type safety violation: <code>user</code> might be <code>null</code> or <code>undefined</code></li> <li>Incomplete error handling: Network failures unhandled</li> <li>Contextual mismatch: May not match project's error handling patterns</li> </ol> <p>Each issue requires detection, diagnosis, and repair—often through multiple LLM calls, consuming tokens and time.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#the-cost-of-post-hoc-validation","level":3,"title":"The Cost of Post-Hoc Validation","text":"<p>Post-generation validation creates a costly feedback loop:</p> <p>Iteration 1: Generate code → Compile → Find type errors → Prompt for fixes Iteration 2: Generate fixes → Compile → Find new errors → Prompt again Iteration 3: Generate fixes → Compile → Test → Find semantic errors → Prompt again ...</p> <p>In practice, research shows unconstrained generation often requires 3-5 iterations before producing working code. Each iteration:</p> <ul> <li>Consumes LLM API calls (cost)</li> <li>Increases latency (time)</li> <li>Risks context window overflow (technical limitation)</li> <li>Frustrates developers (usability)</li> </ul>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#type-errors-in-generated-code","level":3,"title":"Type Errors in Generated Code","text":"<p>Type errors are particularly problematic because they cascade. A single type mismatch can cause:</p> <ul> <li>Compilation failures blocking all downstream work</li> <li>Silent bugs when type coercion hides errors</li> <li>Integration failures when code doesn't match API contracts</li> <li>Maintenance burden as type-unsafe code spreads through the codebase</li> </ul> <p>Research by Mündler et al. (PLDI 2025) found that unconstrained LLMs produce type errors in over 50% of generated functions for typed languages like TypeScript and Rust.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#context-loss-in-large-codebases","level":3,"title":"Context Loss in Large Codebases","text":"<p>Real-world code generation occurs within existing codebases with:</p> <ul> <li>Existing type hierarchies (classes, interfaces, type aliases)</li> <li>Project conventions (naming, error handling, async patterns)</li> <li>Available functions (APIs, utilities, helpers)</li> <li>Imported dependencies (libraries, frameworks)</li> </ul> <p>Unconstrained LLMs cannot reliably leverage this context because:</p> <ol> <li>Context must fit in LLM's input window (limited)</li> <li>LLM has no semantic understanding of types (statistical only)</li> <li>LLM cannot enumerate valid type paths (no formal reasoning)</li> <li>LLM cannot verify constraints incrementally (post-hoc validation only)</li> </ol>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#the-need-for-constraint-first-generation","level":3,"title":"The Need for Constraint-First Generation","text":"<p>These challenges point to a fundamental requirement: constraints must be enforced during generation, not after.</p> <p>MAZE addresses this through:</p> <ul> <li>Syntactic constraints: CFG grammars ensure valid syntax from the start</li> <li>Type constraints: Type inhabitation search finds valid type paths before generation</li> <li>Semantic constraints: Test-driven properties guide behavior</li> <li>Contextual constraints: Learned patterns enforce project consistency</li> </ul> <p>By compiling these constraints into the generation process, MAZE produces code that is correct-by-construction rather than correct-after-iteration.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#3-architecture-overview","level":2,"title":"3. Architecture Overview","text":"<p>MAZE's architecture consists of five integrated stages that transform a code generation request into validated, type-correct code:</p> <p></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#stage-1-context-indexer","level":3,"title":"Stage 1: Context Indexer","text":"<p>Purpose: Extract structured information from source code to inform constraint synthesis</p> <p>Input: Source code files from the target project Output: Symbols, type signatures, patterns, and project conventions</p> <p>Current Implementation: - TypeScript Indexer ✅ Complete (source)   - Extracts functions, classes, interfaces, type aliases   - Parses type annotations and generic parameters   - Detects project style (indentation, quotes, semicolons)   - Identifies test patterns (Jest, Mocha, Vitest)</p> <p>Planned: Python, Rust, Go, Zig indexers</p> <p>Technical Approach: - tree-sitter parsing for fast AST extraction - Optional LSP integration (tsserver) for enhanced type information - Symbol database for efficient lookup</p> <p>Example Output (simplified): <pre><code>{\n  \"functions\": [\n    {\n      \"name\": \"fetchUser\",\n      \"params\": [{\"name\": \"id\", \"type\": \"string\"}],\n      \"returns\": \"Promise&lt;User | null&gt;\",\n      \"async\": true\n    }\n  ],\n  \"types\": [\n    {\n      \"name\": \"User\",\n      \"kind\": \"interface\",\n      \"properties\": [\n        {\"name\": \"id\", \"type\": \"string\"},\n        {\"name\": \"email\", \"type\": \"string\"},\n        {\"name\": \"name\", \"type\": \"string\"}\n      ]\n    }\n  ],\n  \"style\": {\n    \"indent\": \"2 spaces\",\n    \"quotes\": \"single\",\n    \"semicolons\": true\n  }\n}\n</code></pre></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#stage-2-constraint-synthesis","level":3,"title":"Stage 2: Constraint Synthesis","text":"<p>Purpose: Build hierarchical constraints from indexed context and generation request</p> <p>Input: Indexed context + generation request Output: 4-tier constraint set (syntactic, type, semantic, contextual)</p> <p>Components:</p> <ol> <li>GrammarBuilder ✅ (source)</li> <li>Generates CFG grammars in Lark format</li> <li>Language-specific templates (TypeScript, Python, Rust)</li> <li> <p>Composable grammar rules for functions, classes, expressions</p> </li> <li> <p>TypeToGrammarConverter ✅ (source)</p> </li> <li>Converts type constraints into grammar constraints</li> <li>Implements type inhabitation search results as grammar rules</li> <li> <p>Integrates with llguidance for efficient enforcement</p> </li> <li> <p>SchemaBuilder ✅ (source)</p> </li> <li>Generates JSON Schema for structured output (OpenAI compatibility)</li> <li>Translates CFG grammars to JSON Schema where possible</li> <li>Fallback for providers without full CFG support</li> </ol> <p>Example Constraint (TypeScript async function): <pre><code>?start: async_function\n\nasync_function: \"async\" \"function\" IDENT params ret_type block\n\nparams: \"(\" [param (\",\" param)*] \")\"\nparam: IDENT \":\" type_annotation\n\nret_type: \":\" \"Promise\" \"&lt;\" type_annotation \"&gt;\"\n\ntype_annotation: \"User\" | \"null\" | \"User\" \"|\" \"null\"\n\nblock: \"{\" statement* \"}\"\n\nIDENT: /[a-zA-Z_$][a-zA-Z0-9_$]*/\n\n%ignore /\\s+/\n</code></pre></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#stage-3-decode-orchestrator","level":3,"title":"Stage 3: Decode Orchestrator","text":"<p>Purpose: Generate code under constraints using provider-specific adapters</p> <p>Input: Constraint set + generation prompt Output: Generated code conforming to all constraints</p> <p>Integration: llguidance for fast constraint enforcement</p> <p>Provider Adapters ✅ (source):</p> <ul> <li>OpenAI: JSON Schema mode via structured outputs</li> <li>vLLM: Full CFG grammar support</li> <li>SGLang: Native llguidance integration</li> <li>llama.cpp: Grammar-based generation</li> </ul> <p>Key Technical Challenge: Token-level constraint enforcement</p> <p>llguidance computes which tokens are valid at each decode step based on the current grammar state. This requires:</p> <ol> <li>Grammar automaton: Precomputed from CFG</li> <li>Tokenizer alignment: Grammar states aligned with LLM tokenizer</li> <li>Mask computation: Binary mask over vocabulary at each step</li> <li>Caching: Memoization of grammar state transitions</li> </ol> <p>Upstream Performance (Microsoft Research): ~50μs per token mask computation</p> <p>Process: <pre><code>For each token position:\n  1. Determine current grammar state\n  2. Compute valid next tokens (mask)\n  3. Apply mask to LLM logits\n  4. Sample from constrained distribution\n  5. Update grammar state\n  6. Repeat until EOS or max length\n</code></pre></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#stage-4-post-validation","level":3,"title":"Stage 4: Post-Validation","text":"<p>Purpose: Validate generated code across multiple dimensions in parallel</p> <p>Input: Generated code Output: Validation results with diagnostics</p> <p>Validators (parallel execution):</p> <ol> <li>SyntaxValidator ✅ Complete (source)</li> <li>Language-specific syntax checking</li> <li>Parse tree validation</li> <li> <p>Fast failure detection</p> </li> <li> <p>TypeValidator ✅ Complete (source)</p> </li> <li>Type checking via language-specific tools</li> <li>TypeScript: via TypeScript compiler API</li> <li>Python (planned): via mypy or Pyright</li> <li> <p>Rust (planned): via rust-analyzer</p> </li> <li> <p>TestValidator ✅ Complete (source)</p> </li> <li>Executes tests in RUNE sandbox</li> <li>Behavioral validation</li> <li> <p>Property-based testing support</p> </li> <li> <p>LintValidator ✅ Complete (source)</p> </li> <li>Style checking (ESLint, Ruff, Clippy)</li> <li>Code quality metrics</li> <li>Convention adherence</li> </ol> <p>ValidationPipeline ✅ Complete (source) - Orchestrates parallel validation - Aggregates diagnostics - Determines overall pass/fail status</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#stage-5-repair-loop","level":3,"title":"Stage 5: Repair Loop","text":"<p>Purpose: Refine constraints and regenerate if validation fails</p> <p>Status: 📋 Planned (Phase 4)</p> <p>Planned Components: - RepairOrchestrator: Manages repair iterations - DiagnosticAnalyzer: Interprets validation failures - ConstraintRefinement: Tightens constraints based on diagnostics - Max 3 repair attempts with exponential backoff</p> <p>Repair Strategy (planned): <pre><code>If validation fails:\n  1. Analyze diagnostics (which tier failed?)\n  2. Tighten appropriate constraint tier:\n     - Syntax error → Refine grammar\n     - Type error → Add type constraints\n     - Semantic error → Add test constraints\n  3. Regenerate with refined constraints\n  4. Validate again\n  5. Repeat (max 3 times)\n  6. If still failing → Return partial with diagnostics\n</code></pre></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#integration-flow","level":3,"title":"Integration Flow","text":"<p>MAZE integrates with four external systems:</p> <p></p> <ol> <li>llguidance (Microsoft Research): Constraint enforcement during decoding</li> <li>mnemosyne: Persistent memory for pattern learning across sessions</li> <li>RUNE: Sandboxed execution for safe test validation</li> <li>pedantic_raven: Deep semantic validation (planned integration)</li> </ol> <p>These integrations enable MAZE to: - Enforce constraints efficiently (llguidance) - Learn from past generations (mnemosyne) - Validate safely (RUNE) - Check deep properties (pedantic_raven)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#4-4-tier-constraint-system","level":2,"title":"4. 4-Tier Constraint System","text":"<p>MAZE's core innovation is a hierarchical constraint system that progressively narrows the space of valid programs:</p> <p></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#tier-1-syntactic-constraints-cfg-grammars","level":3,"title":"Tier 1: Syntactic Constraints (CFG Grammars)","text":"<p>Purpose: Ensure generated code is syntactically valid</p> <p>Implementation: Context-Free Grammars (CFG) in Lark format</p> <p>Status: ✅ Complete for TypeScript, partial for Python/Rust</p> <p>Technical Approach:</p> <p>CFG grammars define the valid structure of code at the syntactic level. MAZE uses Lark extended syntax for expressiveness:</p> <pre><code>// TypeScript function grammar\n?start: typescript_function\n\ntypescript_function: [\"export\"] [\"async\"] \"function\" IDENT params [ret_type] block\n\nparams: \"(\" [param_list] \")\"\nparam_list: param (\",\" param)*\nparam: IDENT [\":\" type_annotation] [\"=\" expression]\n\nret_type: \":\" type_annotation\n\ntype_annotation: base_type | union_type | array_type | generic_type\n\nbase_type: \"string\" | \"number\" | \"boolean\" | \"void\" | IDENT\n\nunion_type: type_annotation (\"|\" type_annotation)+\n\narray_type: type_annotation \"[]\"\n\ngeneric_type: IDENT \"&lt;\" type_annotation (\",\" type_annotation)* \"&gt;\"\n\nblock: \"{\" statement* \"}\"\n\nstatement: variable_decl\n         | assignment\n         | return_stmt\n         | if_stmt\n         | for_stmt\n         | expression_stmt\n\n// ... additional rules ...\n\nIDENT: /[a-zA-Z_$][a-zA-Z0-9_$]*/\n\n%ignore /\\s+/\n%ignore /\\/\\/[^\\n]*/  // Single-line comments\n%ignore /\\/\\*(.|\\n)*?\\*\\//  // Multi-line comments\n</code></pre> <p>Benefits: - Guaranteed syntactic validity: Generated code always parses - Language-aware generation: LLM respects language syntax rules - Composability: Grammars can be combined and extended</p> <p>Limitations: - Does not guarantee semantic correctness - Cannot express type constraints directly - Limited to context-free languages (no context-sensitive rules)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#tier-2-type-constraints-inhabitation-search","level":3,"title":"Tier 2: Type Constraints (Inhabitation Search)","text":"<p>Purpose: Ensure generated code is type-correct</p> <p>Implementation: Type inhabitation solver + type-to-grammar conversion</p> <p>Status: ✅ Complete (source)</p> <p>Research Foundation: Mündler et al., \"Type-Constrained Code Generation\" (PLDI 2025, arXiv:2504.09246)</p> <p>Key Concept: Type Inhabitation</p> <p>Given a source type <code>S</code> and target type <code>T</code>, find valid transformation paths:</p> <p></p> <p>Example: Finding <code>User → string</code> paths</p> <p>Given: <pre><code>interface User {\n  id: string;\n  name: string;\n  email: string;\n  age: number;\n  toString(): string;\n}\n</code></pre></p> <p>Valid paths: 1. <code>user.id</code> → <code>string</code> ✅ (property access) 2. <code>user.name</code> → <code>string</code> ✅ (property access) 3. <code>user.email</code> → <code>string</code> ✅ (property access) 4. <code>user.toString()</code> → <code>string</code> ✅ (method call)</p> <p>Invalid paths: - <code>user.age</code> → <code>string</code> ❌ (type mismatch: number → string) - <code>user</code> → <code>string</code> ❌ (no direct conversion)</p> <p>Type Inhabitation Algorithm (simplified):</p> <pre><code>def find_paths(source_type, target_type, context, max_depth=5):\n    \"\"\"Find valid transformation paths from source to target type.\"\"\"\n\n    if source_type == target_type:\n        return [DirectPath()]  # Identity\n\n    if max_depth == 0:\n        return []  # Search depth exceeded\n\n    paths = []\n\n    # Property access: source.property → target\n    for prop in source_type.properties:\n        if prop.type == target_type:\n            paths.append(PropertyPath(prop.name))\n        else:\n            # Recursive search\n            sub_paths = find_paths(prop.type, target_type, context, max_depth - 1)\n            paths.extend([PropertyPath(prop.name, sub) for sub in sub_paths])\n\n    # Method calls: source.method() → target\n    for method in source_type.methods:\n        if method.return_type == target_type:\n            paths.append(MethodPath(method.name, method.params))\n        else:\n            sub_paths = find_paths(method.return_type, target_type, context, max_depth - 1)\n            paths.extend([MethodPath(method.name, method.params, sub) for sub in sub_paths])\n\n    # Available functions: f(source) → target\n    for func in context.functions:\n        if func.param_types[0] == source_type and func.return_type == target_type:\n            paths.append(FunctionPath(func.name))\n\n    return paths\n</code></pre> <p>Type-to-Grammar Conversion:</p> <p>Once valid paths are found, they're converted to grammar rules:</p> <pre><code>// For User → string with paths: .id, .name, .email, .toString()\nuser_to_string: user \".\" (\"id\" | \"name\" | \"email\")\n              | user \".\" \"toString\" \"(\" \")\"\n\nuser: IDENT  // Variable of type User\n</code></pre> <p>Integration with llguidance:</p> <p>These grammar constraints are compiled into prefix automata and enforced during decoding, ensuring the LLM only generates type-valid expressions.</p> <p>Benefits: - Type safety: Generated code is type-correct by construction - Error reduction: Eliminates type errors that plague unconstrained generation - Contextual awareness: Leverages project's type hierarchy</p> <p>Limitations: - Requires type information (typed languages only) - Search space grows exponentially with depth (mitigated by memoization) - Cannot express all type constraints (e.g., dependent types)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#tier-3-semantic-constraints-test-driven","level":3,"title":"Tier 3: Semantic Constraints (Test-Driven)","text":"<p>Purpose: Ensure generated code implements specified behavior</p> <p>Implementation: Test cases + property specifications</p> <p>Status: ✅ Validators complete, orchestration planned</p> <p>Approach:</p> <p>Semantic constraints are specified through:</p> <ol> <li>Concrete test cases: Input/output examples</li> <li>Property-based constraints: Invariants that must hold</li> </ol> <p>Example:</p> <p>For a sorting function:</p> <pre><code>from maze.core.constraints import SemanticConstraint\n\nconstraint = SemanticConstraint(\n    specification=\"Sort array in ascending order\"\n)\n\n# Concrete test cases\nconstraint.add_test_case(\n    input=[3, 1, 2],\n    expected_output=[1, 2, 3]\n)\n\nconstraint.add_test_case(\n    input=[],\n    expected_output=[]\n)\n\n# Properties (invariants)\nconstraint.add_property(\"Output length equals input length\")\nconstraint.add_property(\"Output is sorted (output[i] &lt;= output[i+1])\")\nconstraint.add_property(\"Output contains same elements as input (multiset equality)\")\n</code></pre> <p>Validation Process:</p> <ol> <li>Generate code under syntactic + type constraints</li> <li>Execute test cases in RUNE sandbox (safe, isolated execution)</li> <li>Verify properties hold across test cases</li> <li>If failures detected, extract diagnostics and refine constraints</li> </ol> <p>Integration with RUNE:</p> <p>All test execution happens in RUNE sandboxes to ensure: - Network isolation (no external calls) - Filesystem isolation (temporary directory) - Resource limits (CPU, memory, time) - Deterministic execution (same input → same output)</p> <p>Benefits: - Behavioral correctness: Code does what it's supposed to do - Specification-driven: Tests serve as executable specifications - Safety: RUNE ensures generated code can't cause harm during testing</p> <p>Limitations: - Requires test case creation (manual effort) - Test coverage may be incomplete (edge cases missed) - Execution overhead (slower than pure static checks)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#tier-4-contextual-constraints-learned","level":3,"title":"Tier 4: Contextual Constraints (Learned)","text":"<p>Purpose: Ensure generated code matches project conventions and patterns</p> <p>Implementation: Pattern mining + mnemosyne integration</p> <p>Status: 📋 Planned (Phase 5)</p> <p>Concept:</p> <p>Projects have implicit conventions that go beyond syntax, types, and semantics: - Naming conventions (camelCase, PascalCase, snake_case) - Error handling patterns (try/catch, Result types, null checks) - Async patterns (async/await vs. .then(), Promise usage) - Import organization (alphabetical, grouped by source) - Code structure (guard clauses, early returns)</p> <p>Planned Approach:</p> <ol> <li> <p>Pattern Mining: Analyze existing codebase to extract patterns    <pre><code>from maze.learning.pattern_miner import PatternMiner\n\nminer = PatternMiner()\npatterns = await miner.mine_patterns(\n    project_path=\"./my-project\",\n    language=\"typescript\"\n)\n\n# Extracted patterns:\n# - 95% of functions use async/await (not .then())\n# - 100% of files use single quotes\n# - 88% of functions have guard clauses for null checks\n# - 92% of error handling uses try/catch\n</code></pre></p> </li> <li> <p>Soft Constraints: Weight patterns by frequency    <pre><code>from maze.core.constraints import ContextualConstraint\n\ncontextual = ContextualConstraint(weight=0.5)\n\n# Strong preference (95% prevalence)\ncontextual.add_pattern(\n    pattern=\"use async/await instead of .then()\",\n    weight=0.95\n)\n\n# Weak preference (60% prevalence)\ncontextual.add_pattern(\n    pattern=\"use const over let\",\n    weight=0.60\n)\n</code></pre></p> </li> <li> <p>Adaptive Learning: Update patterns based on success/failure    <pre><code># After successful generation\nawait memory.store_constraint_pattern(\n    pattern=\"async-error-handling\",\n    success=True,\n    metrics={\"compilation\": True, \"tests_passed\": 10}\n)\n\n# After failed generation\nawait memory.store_constraint_pattern(\n    pattern=\"promise-chaining\",\n    success=False,\n    metrics={\"compilation\": False, \"error\": \"type mismatch\"}\n)\n</code></pre></p> </li> </ol> <p>Integration with mnemosyne:</p> <p>mnemosyne provides persistent memory across sessions: - Store successful patterns (what worked) - Store failed patterns (what didn't work) - Recall similar contexts for new generation tasks - Update pattern weights based on long-term success rates</p> <p>Benefits: - Project consistency: Generated code matches existing style - Developer experience: Less manual refactoring needed - Knowledge retention: Learning accumulates across sessions</p> <p>Limitations: - Requires significant codebase for pattern mining - Soft constraints (suggestions, not guarantees) - May reinforce bad patterns if they're common in codebase</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#constraint-composition","level":3,"title":"Constraint Composition","text":"<p>The four tiers compose hierarchically:</p> <pre><code>Syntactic constraints (broadest)\n  ↓ Narrows to syntactically valid programs\nType constraints\n  ↓ Narrows to type-correct programs\nSemantic constraints\n  ↓ Narrows to behaviorally correct programs\nContextual constraints\n  ↓ Narrows to project-conformant programs\n</code></pre> <p>Each tier reduces the search space, progressively guiding the LLM toward the desired output.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#5-type-directed-synthesis","level":2,"title":"5. Type-Directed Synthesis","text":"<p>Type-directed synthesis is MAZE's most sophisticated capability, enabling generation of type-correct code through formal type theory.</p> <p>Research Foundation: Mündler et al. (PLDI 2025) and Blinn et al. (OOPSLA 2024)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#bidirectional-type-inference","level":3,"title":"Bidirectional Type Inference","text":"<p>MAZE implements bidirectional type inference to propagate type information in both directions:</p> <p>Synthesis mode (bottom-up): Infer type of expression from sub-expressions <pre><code>expression → inferred_type\n</code></pre></p> <p>Checking mode (top-down): Check if expression matches expected type <pre><code>expression + expected_type → pass/fail\n</code></pre></p> <p>Example:</p> <pre><code>// Synthesis: Infer type of function call\nconst result = fetchUser(\"123\");\n// Inferred: result : Promise&lt;User | null&gt;\n\n// Checking: Does return value match expected type?\nasync function getUserEmail(id: string): Promise&lt;string&gt; {\n  const user = await fetchUser(id);  // Check: User | null\n  return user.email;  // Check: string (but user might be null! → Error)\n}\n</code></pre>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#type-inhabitation-solver","level":3,"title":"Type Inhabitation Solver","text":"<p>Implementation: src/maze/type_system/inhabitation.py</p> <p>Purpose: Find expressions that inhabit (produce) a given type</p> <p>Algorithm (detailed):</p> <pre><code>class InhabitationSolver:\n    def __init__(self):\n        self.cache = {}  # Memoization for performance\n\n    def find_inhabitants(self, target_type: Type, context: TypeContext, max_depth: int = 5):\n        \"\"\"Find all expressions that produce target_type.\"\"\"\n\n        # Check cache first\n        cache_key = (target_type, context, max_depth)\n        if cache_key in self.cache:\n            return self.cache[cache_key]\n\n        inhabitants = []\n\n        # 1. Variables in scope with target type\n        for var in context.variables:\n            if var.type == target_type:\n                inhabitants.append(VariableExpr(var.name))\n\n        # 2. Function calls that return target type\n        for func in context.functions:\n            if func.return_type == target_type:\n                # Find inhabitants for each parameter\n                param_inhabitants = []\n                for param_type in func.param_types:\n                    param_inhab = self.find_inhabitants(param_type, context, max_depth - 1)\n                    if not param_inhab:\n                        break  # Can't inhabit this parameter\n                    param_inhabitants.append(param_inhab)\n\n                if len(param_inhabitants) == len(func.param_types):\n                    # Can call this function\n                    for param_combo in product(*param_inhabitants):\n                        inhabitants.append(FunctionCallExpr(func.name, param_combo))\n\n        # 3. Property access on available objects\n        for var in context.variables:\n            for prop in var.type.properties:\n                if prop.type == target_type:\n                    inhabitants.append(PropertyAccessExpr(var.name, prop.name))\n\n        # 4. Method calls on available objects\n        for var in context.variables:\n            for method in var.type.methods:\n                if method.return_type == target_type:\n                    # Similar parameter inhabitation logic as functions\n                    # ...\n                    pass\n\n        # 5. Constructors that create target type\n        if hasattr(target_type, 'constructor'):\n            # ...\n            pass\n\n        # Cache and return\n        self.cache[cache_key] = inhabitants\n        return inhabitants\n</code></pre> <p>Optimization Techniques:</p> <ol> <li>Memoization: Cache results to avoid redundant searches</li> <li>Depth limiting: Prevent infinite recursion (default: max_depth=5)</li> <li>Ranking: Prioritize simpler expressions (fewer steps)</li> <li>Pruning: Eliminate type-incompatible paths early</li> </ol>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#typed-hole-filling","level":3,"title":"Typed Hole Filling","text":"<p>Implementation: src/maze/type_system/holes.py</p> <p>Research Foundation: Blinn et al., \"Statically Contextualizing LLMs with Typed Holes\" (OOPSLA 2024, arXiv:2409.00921)</p> <p>Concept: Partial code with \"holes\" to be filled</p> <p>Example:</p> <pre><code>async function getUserEmail(id: string): Promise&lt;string&gt; {\n  const user = await fetchUser(id);\n\n  if (user === null) {\n    /*__HOLE__*/  // What should we return here?\n  }\n\n  return /*__HOLE__*/;  // What expression returns string from User?\n}\n</code></pre> <p>Hole Filling Process:</p> <ol> <li>Detect hole markers: <code>/*__HOLE__*/</code> or similar</li> <li>Infer expected type: Analyze surrounding context</li> <li>First hole: Inside <code>if</code> returning <code>Promise&lt;string&gt;</code> → expect <code>string | Promise&lt;string&gt;</code></li> <li>Second hole: Return statement in function returning <code>Promise&lt;string&gt;</code> → expect <code>string</code></li> <li>Find inhabitants: Use inhabitation solver</li> <li>First hole: Could return <code>\"\"</code>, <code>throw new Error(...)</code>, etc.</li> <li>Second hole: <code>user.email</code> (User has email: string property)</li> <li>Rank candidates: Prefer simpler, more direct expressions</li> <li>Generate completion: Fill hole with highest-ranked candidate</li> </ol> <p>Integration with LLM:</p> <p>Instead of asking the LLM to generate complete functions, MAZE can: 1. Generate partial code with typed holes 2. Use type inhabitation to find valid hole completions 3. Let LLM choose among valid candidates (constrained generation)</p> <p>This hybrid approach combines LLM creativity with formal correctness guarantees.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#6-integration-ecosystem","level":2,"title":"6. Integration Ecosystem","text":"<p>MAZE integrates with four external systems, each providing complementary capabilities:</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#llguidance-constraint-enforcement","level":3,"title":"llguidance: Constraint Enforcement","text":"<p>Source: Microsoft Research, guidance-ai/llguidance</p> <p>Purpose: Efficient constraint enforcement during LLM decoding</p> <p>How it Works:</p> <p>llguidance compiles CFG grammars into finite-state automata, then computes token-level masks during generation:</p> <pre><code>Grammar (Lark) → Automaton → Token Masks → Constrained Generation\n</code></pre> <p>Performance (upstream benchmarks): - Mask computation: ~50μs per token (p99, 128k tokenizer) - Grammar compilation: &lt;50ms for typical programming language grammars - Memory overhead: ~10MB per grammar automaton</p> <p>MAZE Integration: src/maze/integrations/llguidance/</p> <pre><code>from maze.integrations.llguidance import LLGuidanceAdapter\n\nadapter = LLGuidanceAdapter(\n    mask_cache_size=100000,  # LRU cache for mask reuse\n    enable_profiling=True     # Track performance metrics\n)\n\n# Build parser from grammar\nparser = adapter.build_parser(grammar_string)\n\n# During generation, compute masks\nfor position in range(max_length):\n    mask = adapter.compute_mask(parser, current_state)\n    constrained_logits = apply_mask(logits, mask)\n    token = sample(constrained_logits)\n    current_state = update_state(current_state, token)\n</code></pre> <p>Benefits: - Proven efficiency (Microsoft Research backing) - Provider-agnostic (works with any transformer LLM) - Actively maintained (regular updates)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#mnemosyne-persistent-memory","level":3,"title":"mnemosyne: Persistent Memory","text":"<p>Source: rand/mnemosyne, Documentation</p> <p>Purpose: Semantic memory and learning across sessions</p> <p>MAZE Use Cases:</p> <ol> <li> <p>Pattern Storage: Remember successful constraint patterns    <pre><code>mnemosyne remember \\\n  -c \"TypeScript async function with Promise&lt;T&gt; return: 94% success\" \\\n  -n \"project:maze:constraint:typescript\" \\\n  -i 8 \\\n  -t \"constraint,typescript,async,success\"\n</code></pre></p> </li> <li> <p>Context Recall: Retrieve relevant patterns for new tasks    <pre><code>mnemosyne recall \\\n  -q \"async error handling patterns typescript\" \\\n  -n \"project:maze:constraint:typescript\" \\\n  -l 10\n</code></pre></p> </li> <li> <p>Adaptive Learning: Update pattern weights based on outcomes    <pre><code># After successful generation\nawait memory.update_pattern_weight(\n    pattern_id=\"async-error-handling\",\n    success=True,\n    metrics={\"compilation\": True, \"tests\": 10}\n)\n</code></pre></p> </li> </ol> <p>Integration: src/maze/integrations/mnemosyne/</p> <p>Status: ✅ Basic integration complete, full adaptive learning planned (Phase 5)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#rune-sandboxed-execution","level":3,"title":"RUNE: Sandboxed Execution","text":"<p>Source: rand/RUNE, Documentation</p> <p>Purpose: Safe, isolated execution for test validation</p> <p>MAZE Use Cases:</p> <ol> <li>Test Execution: Run generated code's tests without risk</li> <li>Property Verification: Check invariants hold</li> <li>Behavioral Validation: Ensure code does what it claims</li> </ol> <p>Safety Guarantees: - Network isolation: No external network access - Filesystem isolation: Temporary directory, no access to host filesystem - Resource limits: CPU, memory, and time quotas enforced - Deterministic execution: Same input → same output</p> <p>Integration: src/maze/integrations/rune/</p> <pre><code>from maze.integrations.rune import RuneAdapter\n\nrune = RuneAdapter()\n\n# Execute tests in sandbox\nresult = await rune.execute_tests(\n    code=generated_code,\n    tests=specification.tests,\n    timeout=30,           # 30 second limit\n    memory_limit_mb=512   # 512MB memory limit\n)\n\nif result.passed:\n    print(f\"All {len(result.results)} tests passed\")\nelse:\n    # Extract diagnostics for repair loop\n    failed_tests = [r for r in result.results if not r.success]\n    diagnostics = extract_diagnostics(failed_tests)\n</code></pre> <p>Status: ✅ Complete integration via RuneExecutor</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#pedantic_raven-quality-enforcement","level":3,"title":"pedantic_raven: Quality Enforcement","text":"<p>Source: rand/pedantic_raven</p> <p>Purpose: Deep semantic validation and code quality checks</p> <p>MAZE Use Cases (planned):</p> <ol> <li>Semantic Property Validation: Beyond test cases</li> <li>Code Quality Metrics: Complexity, maintainability</li> <li>Best Practice Enforcement: Language-specific idioms</li> </ol> <p>Status: 📋 Placeholder exists, full integration planned (Phase ⅘)</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#7-implementation-status-and-roadmap","level":2,"title":"7. Implementation Status and Roadmap","text":"","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#current-status-active-development","level":3,"title":"Current Status: Active Development","text":"<p>MAZE has completed its core architectural foundation (Phases 1-3) and is actively building the validation and repair pipeline (Phase 4).</p> <p>Timeline: - Phase 1 (Complete): November 2025 - Foundation - Phase 2 (Complete): November 2025 - Syntactic Constraints - Phase 3 (Complete): November 2025 - Type System - Phase 4 (In Progress): November-December 2025 - Validation &amp; Repair - Phase 5 (Planned): Q1 2026 - Adaptive Learning - Phase 6 (Planned): Q2 2026 - Production</p> <p></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#phase-1-3-core-system-complete","level":3,"title":"Phase 1-3: Core System ✅ COMPLETE","text":"<p>10,847 lines of code across 43 source files</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#phase-1-foundation","level":4,"title":"Phase 1: Foundation","text":"<ul> <li>✅ Core type system (types.py)</li> <li>✅ Constraint abstractions (constraints.py)</li> <li>✅ llguidance integration (integrations/llguidance/)</li> <li>✅ TypeScript indexer (indexer/languages/typescript.py)</li> <li>✅ Test infrastructure (29 test files)</li> </ul>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#phase-2-syntactic-synthesis","level":4,"title":"Phase 2: Syntactic Synthesis","text":"<ul> <li>✅ Grammar builder (synthesis/grammar_builder.py)</li> <li>✅ JSON Schema builder (synthesis/schema_builder.py)</li> <li>✅ Provider adapters (orchestrator/providers/)</li> <li>✅ Language grammars: TypeScript (complete), Python/Rust (partial)</li> </ul>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#phase-3-type-system","level":4,"title":"Phase 3: Type System","text":"<p>2,124 lines dedicated to type system</p> <ul> <li>✅ Type inference engine (type_system/inference.py)</li> <li>✅ Type inhabitation solver (type_system/inhabitation.py)</li> <li>✅ Typed holes (type_system/holes.py)</li> <li>✅ Type-to-grammar converter (type_system/grammar_converter.py)</li> <li>✅ TypeScript type system (type_system/languages/typescript.py)</li> </ul> <p>Git Commit: a3fad53 - \"chore: Sync Beads state after Phase 3 completion\"</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#phase-4-validation-repair-in-progress-610-complete","level":3,"title":"Phase 4: Validation &amp; Repair 🚧 IN PROGRESS (6/10 complete)","text":"<p>Recent Progress (as of November 8, 2025):</p> <p>✅ Complete Components: 1. SyntaxValidator (validation/syntax.py) - Commit 013846c 2. TypeValidator (validation/types.py) - Commit a1b463c 3. TestValidator (validation/tests.py) - Commit 3f8f006 4. LintValidator (validation/lint.py) - Commit 7a91e04 5. RuneExecutor (integrations/rune/) - Commit 0e358b4 6. ValidationPipeline (validation/pipeline.py) - Commit b4b31c6</p> <p>📋 Remaining Tasks: - RepairOrchestrator: Manages repair iteration logic - DiagnosticAnalyzer: Interprets validation failures - ConstraintRefinement: Tightens constraints based on diagnostics - Full pedantic_raven integration: Deep semantic validation</p> <p>Expected Completion: December 2025</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#phase-5-adaptive-learning-planned","level":3,"title":"Phase 5: Adaptive Learning 📋 PLANNED","text":"<p>Timeline: Q1 2026</p> <p>Components: - Pattern mining from existing codebases - Constraint learning from generation outcomes - Full mnemosyne integration for persistent learning - Project-specific pattern adaptation - Success rate tracking and weight adjustment</p> <p>Goal: Learn project conventions and improve over time</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#phase-6-production-planned","level":3,"title":"Phase 6: Production 📋 PLANNED","text":"<p>Timeline: Q2 2026</p> <p>Components: - Performance optimization (speculative decoding, parallelization) - Multi-language indexers (Python, Rust, Go, Zig completion) - IDE integrations (VSCode, IntelliJ plugins) - Comprehensive benchmarking:   - HumanEval (164 Python problems)   - MBPP (974 Python problems with types)   - SWE-bench-lite (real-world bug fixes) - Production deployment guides - Stability and reliability hardening</p> <p>Goal: Production-ready system with proven benchmarks</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#8-research-foundation","level":2,"title":"8. Research Foundation","text":"<p>MAZE builds on established research in constrained generation, program synthesis, and type theory:</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#type-constrained-code-generation-pldi-2025","level":3,"title":"Type-Constrained Code Generation (PLDI 2025)","text":"<p>Paper: Mündler et al., \"Type-Constrained Code Generation with Language Models\" Venue: PLDI 2025 arXiv: 2504.09246</p> <p>Key Contributions: 1. Type constraints as prefix automata 2. Bidirectional type inference for LLM guidance 3. Reported &gt;50% reduction in compilation errors</p> <p>MAZE Implementation: - Type inhabitation solver implements similar search algorithm - Type-to-grammar conversion enables llguidance integration - Architecture designed to support reported error reduction</p> <p>Status: Core algorithms implemented, benchmarking pending</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#statically-contextualizing-llms-with-typed-holes-oopsla-2024","level":3,"title":"Statically Contextualizing LLMs with Typed Holes (OOPSLA 2024)","text":"<p>Paper: Blinn et al., \"Statically Contextualizing Large Language Models with Typed Holes\" Venue: OOPSLA 2024 arXiv: 2409.00921</p> <p>Key Contributions: 1. Typed holes for partial code completion 2. Static context extraction for LLM guidance 3. Evaluation on real-world TypeScript codebases</p> <p>MAZE Implementation: - Typed hole filling module: type_system/holes.py - Hole marker detection and context extraction - Type inhabitation for hole completion</p> <p>Status: Implementation complete based on paper methodology</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#llguidance-constraint-enforcement-for-llms","level":3,"title":"LLGuidance: Constraint Enforcement for LLMs","text":"<p>Source: Microsoft Research, guidance-ai/llguidance</p> <p>Key Contributions: 1. Efficient CFG grammar enforcement during decoding 2. Sub-100μs token mask computation 3. Provider-agnostic integration</p> <p>MAZE Integration: - Primary constraint enforcement mechanism - Provider adapters leverage llguidance for all supported LLMs - Performance characteristics validated by upstream benchmarks</p> <p>Status: Full integration complete</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#related-work","level":3,"title":"Related Work","text":"<p>OllamaHoles (Tritlo, GitHub): Inspired MAZE's typed hole approach</p> <p>Synchromesh (Poesia et al.): Grammar-based constrained generation (predecessor to llguidance)</p> <p>LMQL (Beurer-Kellner et al.): Query language for LLMs with constraints</p> <p>InCoder (Fried et al.): Fill-in-the-middle code generation</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#9-architecture-validation","level":2,"title":"9. Architecture Validation","text":"<p>All claims in this whitepaper are validated against the codebase at tag <code>v0.1.0-whitepaper</code>.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#code-statistics","level":3,"title":"Code Statistics","text":"Metric Value Source Total source files 43 <code>find src/maze -name \"*.py\" \\| wc -l</code> Total source lines 10,847 <code>find src/maze -name \"*.py\" -exec wc -l {} +</code> Test files 29 <code>find tests -name \"*.py\" \\| wc -l</code> Type system lines 2,124 <code>wc -l src/maze/type_system/*.py</code>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#component-verification","level":3,"title":"Component Verification","text":"<p>Core Type System ✅: - src/maze/core/types.py - src/maze/core/constraints.py</p> <p>Type System ✅ (2,124 lines): - src/maze/type_system/inference.py - src/maze/type_system/inhabitation.py - src/maze/type_system/holes.py - src/maze/type_system/grammar_converter.py - src/maze/type_system/languages/typescript.py</p> <p>Synthesis ✅: - src/maze/synthesis/grammar_builder.py - src/maze/synthesis/schema_builder.py</p> <p>Validation ✅: - src/maze/validation/syntax.py - src/maze/validation/types.py - src/maze/validation/tests.py - src/maze/validation/lint.py - src/maze/validation/pipeline.py</p> <p>Integrations ✅: - src/maze/integrations/llguidance/ - src/maze/integrations/mnemosyne/ - src/maze/integrations/rune/</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#git-commit-history","level":3,"title":"Git Commit History","text":"<p>Phase Completions: - Phase 3 integration: <code>161b821</code> - \"feat: Complete Phase 3 with integration and orchestration\" - Phase 3 sync: <code>a3fad53</code> - \"chore: Sync Beads state after Phase 3 completion\"</p> <p>Phase 4 Progress: - SyntaxValidator: <code>013846c</code> - TypeValidator: <code>a1b463c</code> - TestValidator: <code>3f8f006</code> - LintValidator: <code>7a91e04</code> - RuneExecutor: <code>0e358b4</code> - ValidationPipeline: <code>b4b31c6</code></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#test-infrastructure","level":3,"title":"Test Infrastructure","text":"<p>Test Organization: <pre><code>tests/\n├── unit/              # Component-level tests\n├── integration/       # Multi-component tests\n├── e2e/              # End-to-end scenarios\n└── conftest.py       # Pytest configuration\n</code></pre></p> <p>Total test files: 29</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#note-on-performance-claims","level":3,"title":"Note on Performance Claims","text":"<p>The CHANGELOG.md documents performance achievements: - Token mask computation (p99): 50μs - Grammar compilation: 42ms - Type error reduction: 94% - Compilation success rate: 97% - Memory usage: 600MB - Cache hit rate: 89%</p> <p>Validation status: These metrics are documented but the benchmarks/ directory is currently empty. This whitepaper focuses on architectural design rather than specific performance numbers pending benchmark suite implementation.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#10-getting-started","level":2,"title":"10. Getting Started","text":"","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#installation","level":3,"title":"Installation","text":"<p>MAZE requires Python 3.10+ and uses <code>uv</code> for dependency management:</p> <pre><code># Clone repository\ngit clone https://github.com/rand/maze\ncd maze\n\n# Install dependencies\nuv pip install -e \".[dev]\"\n\n# Verify installation\nuv run python -c \"import maze; print('MAZE installed successfully')\"\n</code></pre>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#basic-usage-conceptual","level":3,"title":"Basic Usage (Conceptual)","text":"<pre><code>from maze.core.constraints import ConstraintSet, SyntacticConstraint\nfrom maze.type_system.context import TypeContext\nfrom maze.orchestrator import generate\n\n# 1. Define constraints\nconstraints = ConstraintSet()\n\n# Add syntactic constraint (TypeScript)\nconstraints.add(SyntacticConstraint.from_language(\"typescript\"))\n\n# 2. Optionally add type context\ntype_context = TypeContext()\ntype_context.add_type(\"User\", {\n    \"id\": \"string\",\n    \"name\": \"string\",\n    \"email\": \"string\"\n})\n\n# 3. Generate code\ncode = generate(\n    prompt=\"Create an async function that fetches a user by ID and returns their email\",\n    constraints=constraints,\n    type_context=type_context\n)\n\nprint(code)\n</code></pre> <p>Expected output (with type constraints): <pre><code>async function getUserEmail(id: string): Promise&lt;string&gt; {\n  const user = await fetchUser(id);\n\n  if (user === null) {\n    throw new Error(`User with ID ${id} not found`);\n  }\n\n  return user.email;\n}\n</code></pre></p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#next-steps","level":3,"title":"Next Steps","text":"<p>Explore the Documentation: - CLAUDE.md: Comprehensive development guide - AGENT_GUIDE.md: Operational workflows - Validation Manifest: Code verification</p> <p>Contribute: - GitHub: https://github.com/rand/maze - Issues: Report bugs, request features - Pull Requests: Contribute code, documentation, benchmarks</p> <p>Learn More: - Research papers: See Section 8 - Related projects: mnemosyne, RUNE</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#11-conclusion","level":2,"title":"11. Conclusion","text":"","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#summary-of-contributions","level":3,"title":"Summary of Contributions","text":"<p>MAZE introduces a novel approach to code generation that shifts from post-hoc validation to pre-generation constraint enforcement:</p> <ol> <li> <p>4-Tier Constraint Hierarchy: Progressive constraint tightening from syntax through types, semantics, and context</p> </li> <li> <p>Type-Directed Synthesis: Bidirectional type inference and inhabitation search for type-correct code paths</p> </li> <li> <p>Multi-System Integration: Seamless integration with llguidance (constraint enforcement), mnemosyne (persistent learning), RUNE (sandboxed validation), and pedantic_raven (quality enforcement)</p> </li> <li> <p>Research-Backed Design: Built on PLDI 2025 and OOPSLA 2024 research, validated through implementation</p> </li> <li> <p>Provider-Agnostic Architecture: Support for OpenAI, vLLM, SGLang, and llama.cpp through unified adapters</p> </li> </ol>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#current-state-solid-foundation","level":3,"title":"Current State: Solid Foundation","text":"<p>With 10,847 lines of code across 43 source files, MAZE has completed its core architectural foundation:</p> <ul> <li>Phase 1-3: Type system, constraint synthesis, and core integrations complete</li> <li>Phase 4: Validation pipeline 60% complete (6/10 tasks)</li> <li>Phase 5-6: Adaptive learning and production hardening planned</li> </ul> <p>The implemented components demonstrate the viability of constraint-first generation and provide a foundation for the next generation of AI-assisted development tools.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#future-work","level":3,"title":"Future Work","text":"<p>Short Term (Phase 4, Q4 2025): - Complete repair orchestrator - Diagnostic analyzer for intelligent constraint refinement - Full pedantic_raven integration</p> <p>Medium Term (Phase 5, Q1 2026): - Pattern mining from codebases - Adaptive constraint learning - Project-specific pattern adaptation</p> <p>Long Term (Phase 6, Q2 2026): - Multi-language indexer completion (Python, Rust, Go, Zig) - Comprehensive benchmark evaluation (HumanEval, MBPP, SWE-bench) - IDE integrations (VSCode, IntelliJ) - Production deployment optimization</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#invitation-to-contribute","level":3,"title":"Invitation to Contribute","text":"<p>MAZE is developed as an open-source project. We welcome contributions in:</p> <ul> <li>Benchmarking: Validate performance claims, run evaluations</li> <li>Language Support: Add indexers for Python, Rust, Go, Zig</li> <li>Constraint Synthesis: Improve grammar templates, type inference</li> <li>Testing: Expand test coverage, add property-based tests</li> <li>Documentation: Improve guides, add tutorials, create examples</li> </ul> <p>Visit github.com/rand/maze to get started.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#acknowledgments","level":3,"title":"Acknowledgments","text":"<p>MAZE builds on research by Mündler et al. (PLDI 2025), Blinn et al. (OOPSLA 2024), and the Microsoft Research team behind llguidance. We gratefully acknowledge their foundational work in constrained generation and typed completion.</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#12-resources","level":2,"title":"12. Resources","text":"","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#project-links","level":3,"title":"Project Links","text":"<ul> <li>GitHub Repository: github.com/rand/maze</li> <li>Documentation: CLAUDE.md, AGENT_GUIDE.md</li> <li>Whitepaper: maze whitepaper</li> </ul>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#research-papers","level":3,"title":"Research Papers","text":"<ul> <li>Type-Constrained Code Generation: arXiv:2504.09246 (PLDI 2025)</li> <li>Typed Holes: arXiv:2409.00921 (OOPSLA 2024)</li> </ul>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#related-projects","level":3,"title":"Related Projects","text":"<ul> <li>llguidance: github.com/guidance-ai/llguidance (Microsoft Research)</li> <li>mnemosyne: rand.github.io/mnemosyne (Memory &amp; Learning)</li> <li>RUNE: rand.github.io/RUNE (Sandboxed Execution)</li> </ul>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]},{"location":"whitepaper/whitepaper/#community","level":3,"title":"Community","text":"<ul> <li>Issues: github.com/rand/maze/issues</li> <li>Discussions: github.com/rand/maze/discussions</li> </ul> <p>Version: v0.1.0-whitepaper Last Updated: November 2025 License: [To be determined]</p>","path":["MAZE: Adaptive Constrained Code Generation"],"tags":[]}]}